<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fastify Modular â€” Tutorial Completo</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Syne:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #11111a;
    --surface2: #1a1a28;
    --border: #2a2a40;
    --accent: #7c6aff;
    --accent2: #ff6a9b;
    --accent3: #6affcc;
    --accent4: #ffb86a;
    --text: #e8e8f0;
    --muted: #7a7a9a;
    --code-bg: #0d0d16;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { scroll-behavior: smooth; }
  body { background: var(--bg); color: var(--text); font-family: 'Syne', sans-serif; line-height: 1.7; overflow-x: hidden; }

  /* SIDEBAR */
  .sidebar { position: fixed; left: 0; top: 0; width: 270px; height: 100vh; background: var(--surface); border-right: 1px solid var(--border); overflow-y: auto; z-index: 100; padding: 24px 0; }
  .sidebar-logo { padding: 0 24px 24px; border-bottom: 1px solid var(--border); margin-bottom: 16px; }
  .sidebar-logo .logo-text { font-size: 20px; font-weight: 800; background: linear-gradient(135deg, var(--accent), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
  .sidebar-logo .logo-sub { font-size: 11px; color: var(--muted); font-family: 'JetBrains Mono', monospace; margin-top: 2px; }
  .nav-section { padding: 8px 24px 4px; font-size: 10px; font-weight: 700; color: var(--muted); letter-spacing: 2px; text-transform: uppercase; font-family: 'JetBrains Mono', monospace; }
  .nav-item { display: flex; align-items: center; gap: 10px; padding: 8px 24px; color: var(--muted); text-decoration: none; font-size: 13px; font-weight: 600; transition: all 0.2s; border-left: 2px solid transparent; cursor: pointer; }
  .nav-item:hover, .nav-item.active { color: var(--text); background: var(--surface2); border-left-color: var(--accent); }
  .nav-item .step-badge { width: 20px; height: 20px; background: var(--border); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 10px; font-family: 'JetBrains Mono', monospace; flex-shrink: 0; }
  .nav-item.active .step-badge { background: var(--accent); color: white; }

  /* MAIN */
  .main { margin-left: 270px; min-height: 100vh; }

  /* HERO */
  .hero { padding: 80px 60px 60px; border-bottom: 1px solid var(--border); position: relative; overflow: hidden; }
  .hero::before { content: ''; position: absolute; top: -100px; right: -100px; width: 500px; height: 500px; background: radial-gradient(circle, rgba(124,106,255,0.12) 0%, transparent 70%); pointer-events: none; }
  .hero::after { content: ''; position: absolute; bottom: -80px; left: 100px; width: 400px; height: 400px; background: radial-gradient(circle, rgba(255,106,155,0.08) 0%, transparent 70%); pointer-events: none; }
  .hero-badge { display: inline-flex; align-items: center; gap: 8px; background: rgba(124,106,255,0.1); border: 1px solid rgba(124,106,255,0.3); padding: 6px 14px; border-radius: 100px; font-size: 12px; font-family: 'JetBrains Mono', monospace; color: var(--accent); margin-bottom: 24px; }
  .hero h1 { font-size: clamp(36px, 4vw, 56px); font-weight: 800; line-height: 1.1; margin-bottom: 16px; }
  .hero h1 span { background: linear-gradient(135deg, var(--accent), var(--accent2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
  .hero p { font-size: 18px; color: var(--muted); max-width: 620px; margin-bottom: 32px; }
  .hero-tags { display: flex; flex-wrap: wrap; gap: 8px; }
  .tag { background: var(--surface2); border: 1px solid var(--border); padding: 4px 12px; border-radius: 6px; font-size: 12px; font-family: 'JetBrains Mono', monospace; color: var(--muted); }
  .tag.green { border-color: rgba(106,255,204,0.3); color: var(--accent3); background: rgba(106,255,204,0.05); }
  .tag.purple { border-color: rgba(124,106,255,0.3); color: var(--accent); background: rgba(124,106,255,0.05); }
  .tag.pink { border-color: rgba(255,106,155,0.3); color: var(--accent2); background: rgba(255,106,155,0.05); }
  .tag.yellow { border-color: rgba(255,184,106,0.3); color: var(--accent4); background: rgba(255,184,106,0.05); }

  /* CONTENT */
  .content { padding: 0 60px 80px; }

  /* SECTION */
  .section { padding: 60px 0 40px; border-bottom: 1px solid var(--border); }
  .section:last-child { border-bottom: none; }
  .section-header { display: flex; align-items: flex-start; gap: 20px; margin-bottom: 32px; }
  .step-number { width: 44px; height: 44px; background: linear-gradient(135deg, var(--accent), var(--accent2)); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-weight: 800; font-size: 16px; flex-shrink: 0; font-family: 'JetBrains Mono', monospace; }
  .section-title { font-size: 28px; font-weight: 800; margin-bottom: 6px; }
  .section-desc { color: var(--muted); font-size: 14px; }

  /* CODE */
  .code-block { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; overflow: hidden; margin: 20px 0; }
  .code-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--surface); border-bottom: 1px solid var(--border); }
  .code-filename { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--accent3); }
  .code-lang { font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--muted); background: var(--surface2); padding: 2px 8px; border-radius: 4px; }
  .code-block pre { padding: 20px; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 13px; line-height: 1.9; color: #cdd6f4; }
  .cm { color: #585b70; font-style: italic; }

  /* FOLDER TREE */
  .folder-tree { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 24px; font-family: 'JetBrains Mono', monospace; font-size: 13px; line-height: 2.1; margin: 20px 0; }
  .tree-dir { color: var(--accent); font-weight: 700; }
  .tree-file { color: var(--text); }
  .tree-comment { color: var(--muted); font-style: italic; }
  .tree-layer { display: inline-block; padding: 1px 8px; border-radius: 4px; font-size: 10px; margin-left: 8px; vertical-align: middle; }
  .layer-routes { background: rgba(124,106,255,0.15); color: var(--accent); }
  .layer-ctrl { background: rgba(255,106,155,0.15); color: var(--accent2); }
  .layer-svc { background: rgba(106,255,204,0.15); color: var(--accent3); }
  .layer-repo { background: rgba(255,184,106,0.15); color: var(--accent4); }

  /* CALLOUTS */
  .callout { border-radius: 10px; padding: 16px 20px; margin: 16px 0; display: flex; gap: 14px; align-items: flex-start; font-size: 14px; }
  .callout-icon { font-size: 20px; flex-shrink: 0; margin-top: 1px; }
  .callout.info { background: rgba(124,106,255,0.08); border: 1px solid rgba(124,106,255,0.2); }
  .callout.warning { background: rgba(255,184,106,0.08); border: 1px solid rgba(255,184,106,0.2); }
  .callout.success { background: rgba(106,255,204,0.08); border: 1px solid rgba(106,255,204,0.2); }
  .callout.danger { background: rgba(255,106,155,0.08); border: 1px solid rgba(255,106,155,0.2); }
  .callout.info .callout-title { color: var(--accent); }
  .callout.warning .callout-title { color: var(--accent4); }
  .callout.success .callout-title { color: var(--accent3); }
  .callout.danger .callout-title { color: var(--accent2); }
  .callout-title { font-weight: 700; margin-bottom: 4px; }
  .callout p { color: var(--muted); line-height: 1.6; margin: 0; }

  code { font-family: 'JetBrains Mono', monospace; background: var(--surface2); padding: 2px 6px; border-radius: 4px; font-size: 13px; color: var(--accent3); }

  /* LAYER DIAGRAM */
  .layer-diagram { display: flex; flex-direction: column; gap: 0; margin: 24px 0; max-width: 520px; }
  .layer-box { padding: 14px 20px; border-radius: 0; display: flex; align-items: center; justify-content: space-between; font-size: 13px; font-weight: 600; }
  .layer-box:first-child { border-radius: 10px 10px 0 0; }
  .layer-box:last-child { border-radius: 0 0 10px 10px; }
  .layer-box.routes { background: rgba(124,106,255,0.15); border: 1px solid rgba(124,106,255,0.3); border-bottom: none; }
  .layer-box.controller { background: rgba(255,106,155,0.1); border: 1px solid rgba(255,106,155,0.25); border-bottom: none; }
  .layer-box.service { background: rgba(106,255,204,0.1); border: 1px solid rgba(106,255,204,0.25); border-bottom: none; }
  .layer-box.repo { background: rgba(255,184,106,0.1); border: 1px solid rgba(255,184,106,0.25); border-bottom: none; }
  .layer-box.db { background: rgba(100,100,150,0.1); border: 1px solid rgba(100,100,150,0.25); }
  .layer-badge { font-size: 11px; font-family: 'JetBrains Mono', monospace; opacity: 0.7; }

  /* GRID */
  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 20px 0; }
  .card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
  .card h4 { font-size: 14px; font-weight: 700; margin-bottom: 8px; color: var(--accent); }
  .card p { font-size: 13px; color: var(--muted); margin: 0; }

  /* COMPARE */
  .compare { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 20px 0; }
  .compare-box { background: var(--code-bg); border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
  .compare-box.bad { border-color: rgba(255,106,155,0.3); }
  .compare-box.good { border-color: rgba(106,255,204,0.3); }
  .compare-header { padding: 10px 16px; font-size: 12px; font-weight: 700; font-family: 'JetBrains Mono', monospace; }
  .compare-box.bad .compare-header { background: rgba(255,106,155,0.1); color: var(--accent2); }
  .compare-box.good .compare-header { background: rgba(106,255,204,0.1); color: var(--accent3); }
  .compare-box pre { padding: 16px; font-family: 'JetBrains Mono', monospace; font-size: 12px; line-height: 1.8; color: #cdd6f4; overflow-x: auto; }

  h2 { font-size: 20px; font-weight: 700; margin: 28px 0 12px; }
  h3 { font-size: 15px; font-weight: 700; margin: 20px 0 10px; color: var(--accent); font-family: 'JetBrains Mono', monospace; }
  p { color: var(--muted); margin-bottom: 12px; font-size: 15px; }

  ::-webkit-scrollbar { width: 6px; height: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .progress-bar { position: fixed; top: 0; left: 270px; right: 0; height: 2px; background: var(--border); z-index: 200; }
  .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); width: 0%; transition: width 0.1s; }

  @media (max-width: 900px) {
    .sidebar { display: none; }
    .main { margin-left: 0; }
    .hero, .content { padding-left: 24px; padding-right: 24px; }
    .progress-bar { left: 0; }
    .grid-2, .compare { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<div class="progress-bar"><div class="progress-fill" id="progress"></div></div>

<!-- SIDEBAR -->
<aside class="sidebar">
  <div class="sidebar-logo">
    <div class="logo-text">âš¡ Fastify API</div>
    <div class="logo-sub">// JS funcional Â· sin clases</div>
  </div>

  <div class="nav-section">Fundamentos</div>
  <a class="nav-item active" href="#inicio-arq" onclick="setActive(this)"><span class="step-badge">â†’</span> IntroducciÃ³n</a>
  <a class="nav-item" href="#paso-1" onclick="setActive(this)"><span class="step-badge">01</span> InstalaciÃ³n</a>
  <a class="nav-item" href="#paso-2" onclick="setActive(this)"><span class="step-badge">02</span> Estructura</a>
  <a class="nav-item" href="#paso-2b" onclick="setActive(this)"><span class="step-badge">2+</span> Nombrado</a>
  <a class="nav-item" href="#paso-2c" onclick="setActive(this)"><span class="step-badge">2++</span> DTOs</a>
  <a class="nav-item" href="#paso-2d" onclick="setActive(this)"><span class="step-badge">2+++</span> Entities</a>
  <a class="nav-item" href="#paso-3" onclick="setActive(this)"><span class="step-badge">03</span> Entorno (.env)</a>
  <a class="nav-item" href="#paso-4" onclick="setActive(this)"><span class="step-badge">04</span> App + Plugins</a>

  <div class="nav-section">Prisma + BD</div>
  <a class="nav-item" href="#paso-5" onclick="setActive(this)"><span class="step-badge">05</span> Prisma ORM</a>

  <div class="nav-section">MÃ³dulo Ventas</div>
  <a class="nav-item" href="#paso-6" onclick="setActive(this)"><span class="step-badge">06</span> Repository</a>
  <a class="nav-item" href="#paso-7" onclick="setActive(this)"><span class="step-badge">07</span> Service</a>
  <a class="nav-item" href="#paso-8" onclick="setActive(this)"><span class="step-badge">08</span> Controller</a>
  <a class="nav-item" href="#paso-9" onclick="setActive(this)"><span class="step-badge">09</span> Routes + Schema</a>
  <a class="nav-item" href="#paso-10" onclick="setActive(this)"><span class="step-badge">10</span> MÃ³dulo (Plugin)</a>
  <a class="nav-item" href="#paso-11" onclick="setActive(this)"><span class="step-badge">11</span> Subida de Archivos</a>

  <div class="nav-section">MÃ³dulo Trabajadores</div>
  <a class="nav-item" href="#paso-24" onclick="setActive(this)"><span class="step-badge">24</span> Workers</a>

  <div class="nav-section">MÃ³dulo Productos</div>
  <a class="nav-item" href="#paso-25" onclick="setActive(this)"><span class="step-badge">25</span> Products</a>

  <div class="nav-section">Seguridad</div>
  <a class="nav-item" href="#paso-12" onclick="setActive(this)"><span class="step-badge">12</span> Auth + JWT</a>
  <a class="nav-item" href="#paso-12b" onclick="setActive(this)"><span class="step-badge">12+</span> Auth.js / Better Auth</a>
  <a class="nav-item" href="#paso-13" onclick="setActive(this)"><span class="step-badge">13</span> Roles y Permisos</a>
  <a class="nav-item" href="#paso-14" onclick="setActive(this)"><span class="step-badge">14</span> CORS</a>
  <a class="nav-item" href="#paso-15" onclick="setActive(this)"><span class="step-badge">15</span> Rate Limiting</a>
  <a class="nav-item" href="#paso-16" onclick="setActive(this)"><span class="step-badge">16</span> SQL Injection</a>

  <div class="nav-section">Infraestructura</div>
  <a class="nav-item" href="#paso-17" onclick="setActive(this)"><span class="step-badge">17</span> Redis Cache</a>
  <a class="nav-item" href="#paso-18" onclick="setActive(this)"><span class="step-badge">18</span> Errores Globales</a>
  <a class="nav-item" href="#paso-19" onclick="setActive(this)"><span class="step-badge">19</span> Logs</a>
  <a class="nav-item" href="#paso-20" onclick="setActive(this)"><span class="step-badge">20</span> PaginaciÃ³n</a>
  <a class="nav-item" href="#paso-21" onclick="setActive(this)"><span class="step-badge">21</span> Swagger</a>
  <a class="nav-item" href="#paso-23" onclick="setActive(this)"><span class="step-badge">23</span> Buenas PrÃ¡cticas</a>
  <a class="nav-item" href="#paso-22" onclick="setActive(this)"><span class="step-badge">22</span> Resumen Final</a>

  <div class="nav-section">MÃ³dulo Trabajadores</div>
  <a class="nav-item" href="#workers-schema" onclick="setActive(this)"><span class="step-badge">W1</span> Schema + Roles</a>
  <a class="nav-item" href="#workers-repository" onclick="setActive(this)"><span class="step-badge">W2</span> Repository</a>
  <a class="nav-item" href="#workers-service" onclick="setActive(this)"><span class="step-badge">W3</span> Service</a>
  <a class="nav-item" href="#workers-controller" onclick="setActive(this)"><span class="step-badge">W4</span> Controller</a>
  <a class="nav-item" href="#workers-routes" onclick="setActive(this)"><span class="step-badge">W5</span> Routes</a>

  <div class="nav-section">MÃ³dulo Productos</div>
  <a class="nav-item" href="#products-schema" onclick="setActive(this)"><span class="step-badge">P1</span> Schema + Entidades</a>
  <a class="nav-item" href="#products-repository" onclick="setActive(this)"><span class="step-badge">P2</span> Repository</a>
  <a class="nav-item" href="#products-service" onclick="setActive(this)"><span class="step-badge">P3</span> Service</a>
  <a class="nav-item" href="#products-controller" onclick="setActive(this)"><span class="step-badge">P4</span> Controller</a>
  <a class="nav-item" href="#products-routes" onclick="setActive(this)"><span class="step-badge">P5</span> Routes</a>
</aside>

<!-- MAIN -->
<main class="main">

  <!-- HERO -->
  <div class="hero" id="inicio">
    <div class="hero-badge">âš¡ JavaScript Funcional Â· Sin Clases Â· Sin TypeScript</div>
    <h1>API de Ventas con<br><span>Fastify Modular</span></h1>
    <p>Tutorial completo usando funciones puras, arquitectura modular con capas, autenticaciÃ³n, cachÃ©, seguridad y documentaciÃ³n. Sin clases, sin TypeScript.</p>
    <div class="hero-tags">
      <span class="tag purple">Fastify 4</span>
      <span class="tag green">Prisma ORM</span>
      <span class="tag green">PostgreSQL</span>
      <span class="tag yellow">Redis Cache</span>
      <span class="tag pink">JWT Auth</span>
      <span class="tag purple">Roles RBAC</span>
      <span class="tag green">Zod Schemas</span>
      <span class="tag yellow">Swagger UI</span>
      <span class="tag pink">Rate Limiting</span>
      <span class="tag purple">Pino Logs</span>
    </div>
  </div>

  <div class="content">

    <!-- INTRO ARQUITECTURA -->
    <div class="section" id="inicio-arq">
      <h2>La arquitectura que vamos a usar</h2>
      <p>Cada mÃ³dulo tiene 4 capas. Las dependencias fluyen siempre hacia abajo â€” nunca hacia arriba.</p>

      <div class="layer-diagram">
        <div class="layer-box routes">
          <span>ğŸ”— routes.js</span>
          <span class="layer-badge">registra endpoints en Fastify</span>
        </div>
        <div class="layer-box controller">
          <span>ğŸ® controller.js</span>
          <span class="layer-badge">maneja request / response HTTP</span>
        </div>
        <div class="layer-box service">
          <span>âš™ï¸ service.js</span>
          <span class="layer-badge">lÃ³gica y reglas de negocio</span>
        </div>
        <div class="layer-box repo">
          <span>ğŸ“¦ repository.js</span>
          <span class="layer-badge">solo habla con la base de datos</span>
        </div>
        <div class="layer-box db">
          <span>ğŸ—„ï¸ PostgreSQL + Redis</span>
          <span class="layer-badge">persistencia Â· cachÃ©</span>
        </div>
      </div>

      <div class="grid-2">
        <div class="card">
          <h4>ğŸ“¦ Repository</h4>
          <p>Solo consultas a la BD. <code>getAll</code>, <code>getById</code>, <code>create</code>, <code>deleteById</code>. Sin lÃ³gica de negocio, sin errores HTTP.</p>
        </div>
        <div class="card">
          <h4>âš™ï¸ Service</h4>
          <p>Decide si la operaciÃ³n se puede ejecutar. Valida reglas, coordina mÃºltiples repositorios, ejecuta transacciones cuando hay atomicidad.</p>
        </div>
        <div class="card">
          <h4>ğŸ® Controller</h4>
          <p>Solo maneja HTTP. Extrae datos del request, llama al service, devuelve la respuesta con el cÃ³digo correcto.</p>
        </div>
        <div class="card">
          <h4>ğŸ”— Routes</h4>
          <p>Registra los endpoints en Fastify. Define el schema de validaciÃ³n y asigna los middlewares (auth, roles).</p>
        </div>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">Regla de oro sobre transacciones</div>
          <p>Cuando una operaciÃ³n involucra varias tablas, tiene validaciones previas o debe ser atÃ³mica â†’ va en el Service usando una transacciÃ³n Prisma. El Repository solo habla con su propia tabla.</p>
        </div>
      </div>
    </div>

    <!-- PASO 1 -->
    <div class="section" id="paso-1">
      <div class="section-header">
        <div class="step-number">01</div>
        <div>
          <div class="section-title">InstalaciÃ³n</div>
          <div class="section-desc">Node.js 18+ requerido. Usamos ES Modules (import/export).</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>mkdir ventas-api && cd ventas-api
npm init -y</pre>
      </div>

      <h3>// dependencias de producciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npm install fastify fastify-plugin \
  @fastify/jwt @fastify/cors @fastify/multipart \
  @fastify/swagger @fastify/swagger-ui \
  @fastify/rate-limit @fastify/sensible \
  @fastify/static \
  @prisma/client \
  ioredis \
  zod \
  dotenv \
  bcryptjs</pre>
      </div>

      <h3>// dependencias de desarrollo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npm install -D nodemon prisma</pre>
      </div>

      <h3>// package.json</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ package.json</span><span class="code-lang">json</span></div>
        <pre>{
  "type": "module",
  "scripts": {
    "dev": "nodemon src/main.js",
    "start": "node src/main.js",
    "db:migrate": "prisma migrate dev",
    "db:generate": "prisma generate",
    "db:studio": "prisma studio"
  }
}</pre>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">"type": "module" es obligatorio</div>
          <p>Esto activa ES Modules. Todos los archivos usarÃ¡n <code>import/export</code> en lugar de <code>require</code>. AsegÃºrate de tener Node.js 18 o superior con <code>node --version</code>.</p>
        </div>
      </div>
    </div>

    <!-- PASO 2 -->
    <div class="section" id="paso-2">
      <div class="section-header">
        <div class="step-number">02</div>
        <div>
          <div class="section-title">Estructura de Carpetas</div>
          <div class="section-desc">Un mÃ³dulo por dominio de negocio, 4 capas por mÃ³dulo.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“ ventas-api/</span><span class="code-lang">tree</span></div>
        <pre>ventas-api/
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.js                       # entry point â€” inicia el servidor
â”‚   â”œâ”€â”€ app.js                        # configura Fastify, plugins y mÃ³dulos
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ env.js                    # valida variables de entorno con Zod
â”‚   â”‚
â”‚   â”œâ”€â”€ modules/                      # un mÃ³dulo por dominio de negocio
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ sales/
â”‚   â”‚   â”‚   â”œâ”€â”€ sales.module.js       # plugin Fastify â€” registra el mÃ³dulo
â”‚   â”‚   â”‚   â”œâ”€â”€ sales.routes.js       # URLs, mÃ©todos y middlewares
â”‚   â”‚   â”‚   â”œâ”€â”€ sales.controller.js   # maneja request y reply HTTP
â”‚   â”‚   â”‚   â”œâ”€â”€ sales.service.js      # lÃ³gica y reglas de negocio
â”‚   â”‚   â”‚   â”œâ”€â”€ sales.repository.js   # consultas a la base de datos
â”‚   â”‚   â”‚   â””â”€â”€ sales.schema.js       # schemas de validaciÃ³n Zod
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ auth/
â”‚   â”‚       â”œâ”€â”€ auth.module.js
â”‚   â”‚       â”œâ”€â”€ auth.routes.js
â”‚   â”‚       â”œâ”€â”€ auth.controller.js
â”‚   â”‚       â”œâ”€â”€ auth.service.js
â”‚   â”‚       â””â”€â”€ auth.schema.js
â”‚   â”‚
â”‚   â””â”€â”€ shared/                       # cÃ³digo compartido entre mÃ³dulos
â”‚       â”œâ”€â”€ plugins/
â”‚       â”‚   â”œâ”€â”€ prisma.plugin.js      # cliente PostgreSQL
â”‚       â”‚   â”œâ”€â”€ jwt.plugin.js         # autenticaciÃ³n JWT
â”‚       â”‚   â”œâ”€â”€ cors.plugin.js        # control de orÃ­genes
â”‚       â”‚   â”œâ”€â”€ redis.plugin.js       # cachÃ© Redis
â”‚       â”‚   â””â”€â”€ swagger.plugin.js     # documentaciÃ³n API
â”‚       â”‚
â”‚       â”œâ”€â”€ middlewares/
â”‚       â”‚   â”œâ”€â”€ auth.middleware.js    # verifica el token JWT
â”‚       â”‚   â””â”€â”€ roles.middleware.js   # verifica el rol del usuario
â”‚       â”‚
â”‚       â”œâ”€â”€ errors/
â”‚       â”‚   â””â”€â”€ error-handler.js     # manejador global de errores
â”‚       â”‚
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ pagination.js        # helper de paginaciÃ³n
â”‚           â”œâ”€â”€ sanitize.js          # sanitizaciÃ³n de inputs
â”‚           â””â”€â”€ file.utils.js        # generaciÃ³n de nombres seguros UUID
â”‚
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma                 # definiciÃ³n de modelos y relaciones
â”‚   â””â”€â”€ migrations/                  # historial de cambios a la BD
â”‚
â”œâ”€â”€ uploads/                          # archivos subidos por usuarios
â”œâ”€â”€ .env                              # variables de entorno (no subir a git)
â””â”€â”€ package.json</pre>
      </div>

      <div class="grid-2">
        <div class="card">
          <h4>ğŸ“ modules/</h4>
          <p>Cada carpeta es un dominio de negocio independiente con sus 4 capas. Agregar uno nuevo no toca los demÃ¡s.</p>
        </div>
        <div class="card">
          <h4>ğŸ“ shared/</h4>
          <p>CÃ³digo que usan todos los mÃ³dulos: plugins de infraestructura, middlewares de seguridad, utilidades y manejo de errores.</p>
        </div>
      </div>
    </div>

    <!-- PASO 2B: NOMBRADO -->
    <div class="section" id="paso-2b">
      <div class="section-header">
        <div class="step-number">2+</div>
        <div>
          <div class="section-title">Convenciones de Nombrado</div>
          <div class="section-desc">CÃ³mo se nombran archivos, carpetas, funciones, variables y constantes en este proyecto.</div>
        </div>
      </div>

      <p>Un buen nombrado hace que el cÃ³digo sea predecible. Cuando ves un archivo, ya sabes quÃ© contiene. Cuando ves una funciÃ³n, ya sabes quÃ© hace. No necesitas leer el cÃ³digo para entenderlo.</p>

      <h3>// archivos â€” kebab-case con sufijo de capa</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ patrÃ³n: nombre-modulo.capa.js</span><span class="code-lang">bash</span></div>
        <pre><span class="cm"># mÃ³dulos â€” nombre del dominio + capa que representa</span>
sales.module.js         <span class="cm"># plugin que registra el mÃ³dulo</span>
sales.routes.js         <span class="cm"># endpoints y middlewares</span>
sales.controller.js     <span class="cm"># handlers HTTP</span>
sales.service.js        <span class="cm"># lÃ³gica de negocio</span>
sales.repository.js     <span class="cm"># consultas a la BD</span>
sales.schema.js         <span class="cm"># schemas de validaciÃ³n Zod</span>

<span class="cm"># shared â€” nombre descriptivo + tipo de archivo</span>
auth.middleware.js       <span class="cm"># middleware de autenticaciÃ³n</span>
roles.middleware.js      <span class="cm"># middleware de roles</span>
error-handler.js         <span class="cm"># manejador de errores</span>
prisma.plugin.js         <span class="cm"># plugin de Prisma</span>
jwt.plugin.js            <span class="cm"># plugin de JWT</span>
pagination.js            <span class="cm"># utilidad de paginaciÃ³n</span>
file.utils.js            <span class="cm"># utilidades de archivos</span>

<span class="cm"># regla: kebab-case (minÃºsculas con guiones)</span>
<span class="cm"># âœ… sales-items.repository.js</span>
<span class="cm"># âŒ SalesItems.Repository.js</span>
<span class="cm"># âŒ salesItemsRepository.js</span></pre>
      </div>

      <h3>// carpetas â€” kebab-case, nombre del dominio</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ carpetas</span><span class="code-lang">bash</span></div>
        <pre><span class="cm"># mÃ³dulos â€” nombre del dominio en singular o plural segÃºn contexto</span>
modules/sales/          <span class="cm"># âœ…</span>
modules/auth/           <span class="cm"># âœ…</span>
modules/products/       <span class="cm"># âœ…</span>
modules/orders/         <span class="cm"># âœ…</span>

<span class="cm"># shared â€” nombre descriptivo del propÃ³sito</span>
shared/plugins/         <span class="cm"># âœ…</span>
shared/middlewares/     <span class="cm"># âœ…</span>
shared/errors/          <span class="cm"># âœ…</span>
shared/utils/           <span class="cm"># âœ…</span>

<span class="cm"># âŒ evitar</span>
modules/Sales/          <span class="cm"># no mayÃºsculas</span>
modules/sale_module/    <span class="cm"># no underscores en carpetas</span>
modules/saleModule/     <span class="cm"># no camelCase en carpetas</span></pre>
      </div>

      <h3>// funciones â€” camelCase, verbo + sustantivo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ funciones por capa</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// repository â€” verbo de datos + modelo</span>
findAllSales()          <span class="cm"># find = buscar, All = todos</span>
findSaleById()          <span class="cm"># find = buscar, By = por criterio</span>
createSale()            <span class="cm"># create = crear</span>
updateSale()            <span class="cm"># update = actualizar</span>
deleteById()            <span class="cm"># delete = eliminar</span>

<span class="cm">// service â€” verbo de negocio + modelo</span>
getAllSales()            <span class="cm"># get = obtener (con lÃ³gica)</span>
getSaleById()           <span class="cm"># get = obtener con verificaciones</span>
createSale()            <span class="cm"># create = crear con reglas</span>
updateSaleStatus()      <span class="cm"># update + quÃ© se actualiza</span>
removeSale()            <span class="cm"># remove = eliminar con permisos</span>

<span class="cm">// controller â€” handler al final siempre</span>
listSalesHandler()      <span class="cm"># list = listado paginado</span>
getSaleHandler()        <span class="cm"># get = obtener uno</span>
createSaleHandler()     <span class="cm"># create = crear</span>
updateSaleHandler()     <span class="cm"># update = actualizar</span>
deleteSaleHandler()     <span class="cm"># delete = eliminar</span>

<span class="cm">// middlewares â€” require + quÃ© verifica</span>
requireAuth()           <span class="cm"># require = es requerido</span>
requireRole()           <span class="cm"># require = es requerido</span></pre>
      </div>

      <h3>// variables â€” camelCase, nombre descriptivo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ variables</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âœ… nombres descriptivos â€” sabes quÃ© contienen sin leerlos</span>
const sale = await getSaleById(id)
const requestUser = request.user
const hasPermission = sale.userId === requestUser.id
const totalPages = Math.ceil(total / limit)
const cachedSale = await redis.get(key)
const hashedPassword = await bcrypt.hash(password, 12)

<span class="cm">// âœ… booleanos â€” prefijo is, has, can, should</span>
const isAdmin = requestUser.role === 'ADMIN'
const isOwner = sale.userId === requestUser.id
const hasStock = product.stock >= item.quantity
const isExpired = token.exp < Date.now()

<span class="cm">// âŒ evitar â€” no descriptivos</span>
const s = await getSaleById(id)     <span class="cm"># Â¿quÃ© es s?</span>
const data = await getSaleById(id)  <span class="cm"># demasiado genÃ©rico</span>
const x = request.user              <span class="cm"># sin sentido</span></pre>
      </div>

      <h3>// constantes â€” UPPER_SNAKE_CASE</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ constantes</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// valores que nunca cambian â€” mayÃºsculas con underscores</span>
const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp']
const MAX_LOGIN_ATTEMPTS = 5
const CACHE_TTL = 300          <span class="cm"># 5 minutos en segundos</span>
const DEFAULT_PAGE_SIZE = 10

<span class="cm">// âœ… fÃ¡cil de identificar en el cÃ³digo que es un valor fijo</span>
<span class="cm">// âŒ evitar magic numbers â€” nÃºmeros sin nombre</span>
await redis.set(key, data, 'EX', 300)      <span class="cm"># Â¿quÃ© es 300?</span>
await redis.set(key, data, 'EX', CACHE_TTL) <span class="cm"># âœ… claro</span></pre>
      </div>

      <h3>// exports â€” quÃ© exportar y cÃ³mo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ exports</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âœ… named exports para funciones â€” permite importar solo lo que necesitas</span>
export async function findSaleById(id) { ... }
export async function createSale(data) { ... }

<span class="cm">// âœ… named exports para plugins y constantes</span>
export const prismaPlugin = fp(async (fastify) => { ... })
export const prisma = new PrismaClient()

<span class="cm">// âœ… al importar â€” desestructurar solo lo necesario</span>
import { findSaleById, createSale } from './sales.repository.js'
import { prisma } from '../../shared/plugins/prisma.plugin.js'

<span class="cm">// âŒ evitar default exports en este proyecto</span>
<span class="cm">// con named exports el editor sabe exactamente quÃ© existe en cada archivo</span>
export default function createSale() { ... }  <span class="cm"># dificulta el autocompletado</span></pre>
      </div>

      <h3>// schemas Zod â€” nombre del recurso + Schema</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ schemas</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// patrÃ³n: acciÃ³n + modelo + Schema</span>
export const createSaleSchema = z.object({ ... })
export const updateSaleSchema = z.object({ ... })
export const getSalesQuerySchema = z.object({ ... })

export const registerSchema = z.object({ ... })
export const loginSchema = z.object({ ... })</pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">âœ…</span>
        <div>
          <div class="callout-title">Resumen de convenciones</div>
          <p>
            <strong>Archivos y carpetas</strong> â†’ kebab-case con sufijo de capa<br>
            <strong>Funciones y variables</strong> â†’ camelCase con verbo descriptivo<br>
            <strong>Constantes</strong> â†’ UPPER_SNAKE_CASE<br>
            <strong>Booleanos</strong> â†’ prefijo is, has, can, should<br>
            <strong>Handlers</strong> â†’ siempre terminan en Handler<br>
            <strong>Schemas</strong> â†’ acciÃ³n + modelo + Schema
          </p>
        </div>
      </div>

    </div>

    <!-- PASO 2C: DTO -->
    <div class="section" id="paso-2c">
      <div class="section-header">
        <div class="step-number">2++</div>
        <div>
          <div class="section-title">DTOs â€” Data Transfer Objects</div>
          <div class="section-desc">Objetos que definen exactamente quÃ© datos se transfieren entre el cliente y el servidor.</div>
        </div>
      </div>

      <p>DTO significa <strong>Data Transfer Object</strong>. Es un objeto que define la forma exacta de los datos que viajan entre capas â€” quÃ© campos acepta, quÃ© tipos tienen, cuÃ¡les son obligatorios y cuÃ¡les opcionales. No tiene lÃ³gica, solo estructura y validaciÃ³n.</p>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">En este proyecto los schemas Zod son los DTOs</div>
          <p>En frameworks como NestJS o en lenguajes como Java, los DTOs son clases separadas con decoradores. En nuestro proyecto con JavaScript funcional, <strong>los schemas de Zod cumplen exactamente esa funciÃ³n</strong> â€” definen la forma de los datos, los validan y los transforman.</p>
        </div>
      </div>

      <h3>// quÃ© problema resuelven los DTOs</h3>
      <div class="compare">
        <div class="compare-box bad">
          <div class="compare-header">âŒ Sin DTO â€” cualquier dato entra</div>
          <pre>export async function createSaleHandler(request, reply) {
  // el body puede traer cualquier cosa
  // { items: "hola" }
  // { items: [{ productId: 123, quantity: -5 }] }
  // { items: [], malicious: "DROP TABLE sales" }
  const sale = await createSale(request.body)
}</pre>
        </div>
        <div class="compare-box good">
          <div class="compare-header">âœ… Con DTO â€” solo datos vÃ¡lidos pasan</div>
          <pre>export async function createSaleHandler(request, reply) {
  // Zod valida la forma exacta
  // si algo no cumple â†’ ZodError â†’ 400
  const body = createSaleSchema.parse(request.body)
  // body.items estÃ¡ garantizado como array de objetos
  // con productId (UUID) y quantity (nÃºmero positivo)
  const sale = await createSale({ userId: request.user.id, items: body.items })
}</pre>
        </div>
      </div>

      <h3>// tipos de DTOs en el proyecto</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.schema.js</span><span class="code-lang">js</span></div>
        <pre>import { z } from 'zod'

<span class="cm">// DTO de entrada â€” datos que llegan en el body del POST</span>
export const createSaleSchema = z.object({
  items: z.array(z.object({
    productId: z.string().uuid('ID de producto invÃ¡lido'),
    quantity:  z.number().int().positive('La cantidad debe ser mayor a 0')
  })).min(1, 'Debes incluir al menos un producto')
})

<span class="cm">// DTO de actualizaciÃ³n â€” datos del PATCH</span>
<span class="cm">// solo acepta exactamente estos 3 valores â€” nada mÃ¡s pasa</span>
export const updateSaleSchema = z.object({
  status: z.enum(['PENDING', 'COMPLETED', 'CANCELLED'])
})

<span class="cm">// DTO de query â€” parÃ¡metros de bÃºsqueda en la URL</span>
<span class="cm">// coerce convierte strings a nÃºmeros automÃ¡ticamente</span>
<span class="cm">// default provee valores por defecto si no se envÃ­an</span>
export const getSalesQuerySchema = z.object({
  page:   z.coerce.number().int().positive().default(1),
  limit:  z.coerce.number().int().positive().max(100).default(10),
  status: z.enum(['PENDING', 'COMPLETED', 'CANCELLED']).optional(),
  userId: z.string().uuid().optional()
})</pre>
      </div>

      <h3>// lo que Zod hace automÃ¡ticamente</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ capacidades de Zod como DTO</span><span class="code-lang">js</span></div>
        <pre"><span class="cm">// 1. validaciÃ³n de tipos</span>
z.string()              <span class="cm">// debe ser string</span>
z.number()              <span class="cm">// debe ser nÃºmero</span>
z.boolean()             <span class="cm">// debe ser boolean</span>
z.array(z.string())     <span class="cm">// debe ser array de strings</span>

<span class="cm">// 2. validaciÃ³n de formato</span>
z.string().uuid()       <span class="cm">// debe ser UUID vÃ¡lido</span>
z.string().email()      <span class="cm">// debe ser email vÃ¡lido</span>
z.string().min(8)       <span class="cm">// mÃ­nimo 8 caracteres</span>
z.number().positive()   <span class="cm">// debe ser mayor a 0</span>
z.number().max(100)     <span class="cm">// mÃ¡ximo 100</span>

<span class="cm">// 3. transformaciÃ³n automÃ¡tica</span>
z.coerce.number()       <span class="cm">// "10" â†’ 10 (string a nÃºmero)</span>
z.string().trim()       <span class="cm">// "  hola  " â†’ "hola"</span>
z.string().toLowerCase() <span class="cm">// "ADMIN" â†’ "admin"</span>

<span class="cm">// 4. valores por defecto</span>
z.number().default(1)   <span class="cm">// si no se envÃ­a, vale 1</span>
z.string().default('PENDING') <span class="cm">// si no se envÃ­a, vale 'PENDING'</span>

<span class="cm">// 5. campos opcionales vs requeridos</span>
z.string()              <span class="cm">// requerido â€” lanza error si falta</span>
z.string().optional()   <span class="cm">// opcional â€” puede no enviarse</span>
z.string().nullable()   <span class="cm">// puede ser null</span></pre>
      </div>

      <h3>// cÃ³mo responde cuando el DTO falla</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ peticiÃ³n invÃ¡lida</span><span class="code-lang">json</span></div>
        <pre">// POST /api/sales con body invÃ¡lido:
{
  "items": [
    { "productId": "no-es-uuid", "quantity": -2 }
  ]
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ respuesta automÃ¡tica â€” 400 Bad Request</span><span class="code-lang">json</span></div>
        <pre">{
  "statusCode": 400,
  "error": "Validation Error",
  "message": "Datos invÃ¡lidos",
  "details": [
    { "field": "items.0.productId", "message": "ID de producto invÃ¡lido" },
    { "field": "items.0.quantity",  "message": "La cantidad debe ser mayor a 0" }
  ]
}</pre>
      </div>

      <h3>// DTOs vs NestJS â€” la diferencia</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ comparaciÃ³n</span><span class="code-lang">js</span></div>
        <pre"><span class="cm">// NestJS â€” DTO como clase con decoradores</span>
export class CreateSaleDto {
  @IsArray()
  @ValidateNested({ each: true })
  items: SaleItemDto[]
}

<span class="cm">// Fastify funcional â€” DTO como schema Zod</span>
export const createSaleSchema = z.object({
  items: z.array(z.object({
    productId: z.string().uuid(),
    quantity:  z.number().int().positive()
  }))
})

<span class="cm">// mismo concepto â€” diferente implementaciÃ³n</span>
<span class="cm">// Zod tiene la ventaja de no necesitar TypeScript ni clases</span></pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">âœ…</span>
        <div>
          <div class="callout-title">Resumen</div>
          <p>Un DTO define quÃ© datos acepta tu API. En este proyecto los schemas Zod son los DTOs. Hay 3 tipos: <strong>body</strong> (POST/PATCH), <strong>query</strong> (parÃ¡metros de URL) y <strong>params</strong> (variables en la ruta como <code>:id</code>). Si los datos no cumplen el DTO, Zod lanza un error y el errorHandler devuelve un 400 automÃ¡ticamente.</p>
        </div>
      </div>

    </div>

    <!-- PASO 2D: ENTITIES -->
    <div class="section" id="paso-2d">
      <div class="section-header">
        <div class="step-number">2+++</div>
        <div>
          <div class="section-title">Entities â€” Entidades</div>
          <div class="section-desc">La representaciÃ³n de un objeto real que existe en la base de datos con identidad Ãºnica.</div>
        </div>
      </div>

      <p>Una entidad es un objeto del mundo real que tiene <strong>identidad Ãºnica</strong> y <strong>persiste en la base de datos</strong>. Cada tabla de tu BD es una entidad. A diferencia de un DTO que es temporal y solo transporta datos, una entidad existe, tiene un <code>id</code> propio y puede cambiar de estado a lo largo del tiempo.</p>

      <div class="grid-2">
        <div class="card">
          <h4>ğŸ“¦ DTO</h4>
          <p>Lo que el cliente <strong>envÃ­a</strong>. Temporal, sin identidad, sin <code>id</code>. Solo define la forma de los datos que entran.</p>
        </div>
        <div class="card">
          <h4>ğŸ—ƒï¸ Entity</h4>
          <p>Lo que <strong>existe en la BD</strong>. Tiene <code>id</code> Ãºnico, fechas, relaciones y estado. Persiste entre peticiones.</p>
        </div>
      </div>

      <h3>// en este proyecto los modelos Prisma son las entidades</h3>
      <p>En NestJS o Java las entidades son clases con decoradores. AquÃ­ cada <code>model</code> del schema Prisma define una entidad â€” su estructura, sus campos y sus relaciones con otras entidades.</p>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prisma/schema.prisma â€” entidades del proyecto</span><span class="code-lang">prisma</span></div>
        <pre><span class="cm">// Entity: User â€” representa un usuario real en el sistema</span>
model User {
  id        String   @id @default(uuid())  <span class="cm">// identidad Ãºnica</span>
  name      String
  email     String   @unique
  password  String
  role      Role     @default(USER)
  createdAt DateTime @default(now())       <span class="cm">// cuÃ¡ndo fue creado</span>
  sales     Sale[]                          <span class="cm">// relaciÃ³n con la entidad Sale</span>
}

<span class="cm">// Entity: Sale â€” representa una venta real</span>
model Sale {
  id        String     @id @default(uuid())
  userId    String
  user      User       @relation(fields: [userId], references: [id])
  total     Decimal    @db.Decimal(10, 2)
  status    SaleStatus @default(PENDING)   <span class="cm">// estado que cambia con el tiempo</span>
  items     SaleItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt          <span class="cm">// cuÃ¡ndo fue modificado por Ãºltima vez</span>
}

<span class="cm">// Entity: Product â€” representa un producto real</span>
model Product {
  id          String     @id @default(uuid())
  name        String
  price       Decimal    @db.Decimal(10, 2)
  stock       Int        @default(0)       <span class="cm">// estado que cambia con cada venta</span>
  createdAt   DateTime   @default(now())
  saleItems   SaleItem[]
}

<span class="cm">// Entity: SaleItem â€” representa un Ã­tem dentro de una venta</span>
<span class="cm">// es una entidad de relaciÃ³n entre Sale y Product</span>
model SaleItem {
  id        String  @id @default(uuid())
  saleId    String
  sale      Sale    @relation(fields: [saleId], references: [id])
  productId String
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)    <span class="cm">// precio al momento de la venta</span>
}</pre>
      </div>

      <h3>// DTO de entrada vs Entity de salida</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ flujo completo â€” POST /api/sales</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// 1. el cliente envÃ­a un DTO â€” solo los datos necesarios para crear</span>
POST /api/sales
{
  "items": [
    { "productId": "abc-123", "quantity": 2 }
  ]
}

<span class="cm">// 2. Zod valida el DTO â€” forma correcta, tipos correctos</span>
const body = createSaleSchema.parse(request.body)

<span class="cm">// 3. el service usa el DTO para crear la Entity en la BD</span>
const sale = await createSale({ userId: request.user.id, items: body.items })

<span class="cm">// 4. Prisma devuelve la Entity completa â€” con id, fechas y relaciones</span>
{
  "id":        "550e8400-e29b-41d4-a716-446655440000",   // identidad Ãºnica
  "userId":    "abc-123",
  "total":     150.00,
  "status":    "PENDING",
  "createdAt": "2026-02-28T21:00:00.000Z",
  "updatedAt": "2026-02-28T21:00:00.000Z",
  "items": [
    {
      "id":        "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "productId": "abc-123",
      "quantity":  2,
      "unitPrice": 75.00
    }
  ]
}</pre>
      </div>

      <h3>// relaciones entre entidades</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ tipos de relaciones</span><span class="code-lang">bash</span></div>
        <pre>User  â†’  Sale      : 1 usuario puede tener N ventas       (1:N)
Sale  â†’  SaleItem  : 1 venta puede tener N Ã­tems          (1:N)
SaleItem â†’ Product : N Ã­tems pueden referenciar 1 producto (N:1)

<span class="cm"># en Prisma las relaciones se definen con @relation</span>
<span class="cm"># el campo con @relation es la llave forÃ¡nea (FK)</span>
userId String
user   User @relation(fields: [userId], references: [id])
<span class="cm">#                              â†‘ FK local    â†‘ PK de User</span></pre>
      </div>

      <h3>// Entity vs DTO â€” comparaciÃ³n final</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ diferencias clave</span><span class="code-lang">bash</span></div>
        <pre>                    DTO                     Entity
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DÃ³nde vive          Schema Zod              Model Prisma
Tiene id            âŒ no                   âœ… siempre
Persiste en BD      âŒ no                   âœ… sÃ­
Tiene fechas        âŒ no                   âœ… createdAt, updatedAt
Lo envÃ­a            El cliente              Lo devuelve Prisma
PropÃ³sito           Validar entrada         Representar datos reales
CuÃ¡ndo se usa       Al recibir peticiÃ³n     Al leer/escribir en BD</pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">âœ…</span>
        <div>
          <div class="callout-title">Resumen</div>
          <p>Los <strong>modelos Prisma son las entidades</strong> â€” representan objetos reales con identidad propia que persisten en la BD. Los <strong>schemas Zod son los DTOs</strong> â€” definen y validan los datos que entran desde el cliente. El flujo siempre es: DTO entra â†’ service procesa â†’ Entity se guarda â†’ Entity completa sale.</p>
        </div>
      </div>

    </div>

    <!-- PASO 3 -->
    <div class="section" id="paso-3">
      <div class="section-header">
        <div class="step-number">03</div>
        <div>
          <div class="section-title">Variables de Entorno</div>
          <div class="section-desc">Validadas con Zod al arrancar. Si falta algo, la app no inicia.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ .env</span><span class="code-lang">env</span></div>
        <pre>NODE_ENV=development
PORT=3000

# PostgreSQL
DATABASE_URL="postgresql://user:password@localhost:5432/ventas_db"

# JWT
JWT_SECRET=una_clave_secreta_muy_larga_minimo_32_caracteres
JWT_EXPIRES_IN=7d

# Redis
REDIS_URL=redis://localhost:6379

# Uploads
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=5242880</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/config/env.js</span><span class="code-lang">js</span></div>
        <pre>import 'dotenv/config'
import { z } from 'zod'

const schema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.string().default('3000'),
  DATABASE_URL: z.string({ required_error: 'DATABASE_URL es requerida' }),
  JWT_SECRET: z.string().min(32, 'JWT_SECRET debe tener al menos 32 caracteres'),
  JWT_EXPIRES_IN: z.string().default('7d'),
  REDIS_URL: z.string().default('redis://localhost:6379'),
  UPLOAD_DIR: z.string().default('./uploads'),
  MAX_FILE_SIZE: z.string().default('5242880'),
})

const result = schema.safeParse(process.env)

if (!result.success) {
  console.error('âŒ Variables de entorno invÃ¡lidas:')
  console.error(result.error.format())
  process.exit(1)   <span class="cm">// falla rÃ¡pido antes de que inicie la app</span>
}

export const env = result.data</pre>
      </div>
    </div>

    <!-- PASO 4 -->
    <div class="section" id="paso-4">
      <div class="section-header">
        <div class="step-number">04</div>
        <div>
          <div class="section-title">App + Entry Point</div>
          <div class="section-desc">ConfiguraciÃ³n central de Fastify.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>import Fastify from 'fastify'
import sensible from '@fastify/sensible'
import rateLimit from '@fastify/rate-limit'
import { env } from './config/env.js'
import { prismaPlugin } from './shared/plugins/prisma.plugin.js'
import { jwtPlugin } from './shared/plugins/jwt.plugin.js'
import { corsPlugin } from './shared/plugins/cors.plugin.js'
import { redisPlugin } from './shared/plugins/redis.plugin.js'
import { swaggerPlugin } from './shared/plugins/swagger.plugin.js'
import { errorHandler } from './shared/errors/error-handler.js'
import { authModule } from './modules/auth/auth.module.js'
import { salesModule } from './modules/sales/sales.module.js'

export function buildApp() {
  const app = Fastify({
    logger: {
      level: env.NODE_ENV === 'production' ? 'info' : 'debug',
      transport: env.NODE_ENV !== 'production'
        ? { target: 'pino-pretty', options: { colorize: true } }
        : undefined
    }
  })

  <span class="cm">// plugins globales</span>
  app.register(sensible)
  app.register(prismaPlugin)
  app.register(jwtPlugin)
  app.register(corsPlugin)
  app.register(redisPlugin)
  app.register(swaggerPlugin)

  <span class="cm">// rate limiting global: 100 req/min por IP</span>
  app.register(rateLimit, {
    max: 100,
    timeWindow: '1 minute',
    errorResponseBuilder: () => ({
      statusCode: 429,
      error: 'Too Many Requests',
      message: 'Demasiadas peticiones. Intenta en 1 minuto.'
    })
  })

  <span class="cm">// manejador global de errores</span>
  app.setErrorHandler(errorHandler)

  <span class="cm">// mÃ³dulos</span>
  app.register(authModule, { prefix: '/api/auth' })
  app.register(salesModule, { prefix: '/api/sales' })

  <span class="cm">// health check</span>
  app.get('/health', async () => ({ status: 'ok', timestamp: new Date() }))

  return app
}
</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/main.js</span><span class="code-lang">js</span></div>
        <pre>import { buildApp } from './app.js'
import { env } from './config/env.js'

const app = buildApp()

try {
  await app.listen({ port: Number(env.PORT), host: '0.0.0.0' })
  app.log.info(`ğŸš€ http://localhost:${env.PORT}`)
  app.log.info(`ğŸ“š Docs: http://localhost:${env.PORT}/docs`)
} catch (err) {
  app.log.error(err)
  process.exit(1)
}</pre>
      </div>
    </div>

    <!-- PASO 5: PRISMA -->
    <div class="section" id="paso-5">
      <div class="section-header">
        <div class="step-number">05</div>
        <div>
          <div class="section-title">Prisma ORM + PostgreSQL</div>
          <div class="section-desc">InstalaciÃ³n, configuraciÃ³n, schema, migraciones y cliente compartido en Fastify.</div>
        </div>
      </div>

      <p>Prisma es un ORM que te permite interactuar con la base de datos usando JavaScript en lugar de SQL. A diferencia de Next.js donde Prisma se integra casi automÃ¡ticamente, en Fastify hay que configurarlo manualmente como un plugin para que el cliente sea compartido en toda la app.</p>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">Diferencia con Next.js</div>
          <p>En Next.js el servidor maneja el ciclo de vida de Prisma por ti. En Fastify tÃº controlas cuÃ¡ndo se conecta y cuÃ¡ndo se desconecta. Por eso necesitas crear un plugin que registre el cliente y lo cierre correctamente cuando la app se apague.</p>
        </div>
      </div>

      <h3>// 1. instalaciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre><span class="cm"># cliente de Prisma para producciÃ³n</span>
npm install @prisma/client

<span class="cm"># CLI de Prisma solo para desarrollo (migraciones, studio, etc.)</span>
npm install -D prisma</pre>
      </div>

      <h3>// 2. inicializar Prisma</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npx prisma init

<span class="cm"># esto crea dos cosas:</span>
<span class="cm"># prisma/schema.prisma  â†’ donde defines tus modelos</span>
<span class="cm"># .env                  â†’ con DATABASE_URL para conectar a PostgreSQL</span></pre>
      </div>

      <h3>// 3. configurar la conexiÃ³n en .env</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ .env</span><span class="code-lang">env</span></div>
        <pre><span class="cm"># formato: postgresql://usuario:password@host:puerto/nombre_db</span>
DATABASE_URL="postgresql://postgres:password@localhost:5432/ventas_db"

<span class="cm"># si usas Supabase, Neon u otro proveedor cloud,</span>
<span class="cm"># copian la URL directamente desde su dashboard</span></pre>
      </div>

      <h3>// 4. definir el schema â€” los modelos son las tablas</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prisma/schema.prisma</span><span class="code-lang">prisma</span></div>
        <pre>generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")  <span class="cm">// lee del .env</span>
}

<span class="cm">// â”€â”€â”€ USUARIOS DEL SISTEMA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
model User {
  id         String   @id @default(uuid())
  name       String
  email      String   @unique
  password   String
  role       Role     @default(USER)
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  sales      Sale[]
  workerId   String?  @unique         <span class="cm">// relaciÃ³n opcional con Trabajador</span>
  worker     Worker?  @relation(fields: [workerId], references: [id])

  @@index([role])
  @@index([isActive])
  @@map("users")
}

<span class="cm">// â”€â”€â”€ MÃ“DULO TRABAJADORES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
model Worker {
  id           String          @id @default(uuid())
  firstName    String
  lastName     String
  dni          String          @unique   <span class="cm">// documento de identidad Ãºnico</span>
  email        String          @unique
  phone        String?
  position     String                    <span class="cm">// cargo â€” un solo cargo por trabajador</span>
  department   String
  salary       Decimal         @db.Decimal(10, 2)
  hireDate     DateTime                  <span class="cm">// fecha de ingreso original</span>
  status       WorkerStatus    @default(ACTIVE)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  movements    WorkerMovement[]          <span class="cm">// historial de movimientos</span>
  user         User?                     <span class="cm">// acceso al aplicativo (opcional)</span>

  @@index([status])
  @@index([department])
  @@index([dni])
  @@map("workers")
}

<span class="cm">// historial de movimientos del personal</span>
model WorkerMovement {
  id          String         @id @default(uuid())
  workerId    String
  worker      Worker         @relation(fields: [workerId], references: [id])
  type        MovementType               <span class="cm">// HIRE, RESIGN, REACTIVATE, POSITION_CHANGE</span>
  description String                     <span class="cm">// detalle del movimiento</span>
  previousPosition String?               <span class="cm">// cargo anterior si hubo cambio</span>
  newPosition      String?               <span class="cm">// nuevo cargo si hubo cambio</span>
  effectiveDate    DateTime              <span class="cm">// fecha efectiva del movimiento</span>
  createdBy   String                     <span class="cm">// id del usuario que lo registrÃ³</span>
  createdAt   DateTime       @default(now())

  @@index([workerId])
  @@index([type])
  @@index([effectiveDate])
  @@map("worker_movements")
}

<span class="cm">// â”€â”€â”€ MÃ“DULO PRODUCTOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
model Product {
  id           String         @id @default(uuid())
  name         String
  description  String?
  sku          String         @unique   <span class="cm">// cÃ³digo Ãºnico del producto</span>
  price        Decimal        @db.Decimal(10, 2)
  stock        Int            @default(0)
  minStock     Int            @default(0)   <span class="cm">// stock mÃ­nimo para alertas</span>
  imageUrl     String?
  isActive     Boolean        @default(true)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  saleItems    SaleItem[]
  stockMoves   StockMovement[]
  discounts    Discount[]

  @@index([isActive])
  @@index([sku])
  @@index([stock])
  @@map("products")
}

<span class="cm">// historial de movimientos de stock</span>
model StockMovement {
  id          String            @id @default(uuid())
  productId   String
  product     Product           @relation(fields: [productId], references: [id])
  type        StockMovementType             <span class="cm">// IN, OUT, ADJUST, RETURN</span>
  quantity    Int                           <span class="cm">// positivo = entrada, negativo = salida</span>
  previousStock Int                         <span class="cm">// stock antes del movimiento</span>
  newStock    Int                           <span class="cm">// stock despuÃ©s del movimiento</span>
  reason      String                        <span class="cm">// motivo del ajuste</span>
  createdBy   String                        <span class="cm">// id del usuario que lo registrÃ³</span>
  createdAt   DateTime          @default(now())

  @@index([productId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

<span class="cm">// descuentos de productos</span>
model Discount {
  id          String       @id @default(uuid())
  productId   String
  product     Product      @relation(fields: [productId], references: [id])
  name        String                    <span class="cm">// nombre del descuento</span>
  percentage  Decimal      @db.Decimal(5, 2)  <span class="cm">// 0-100</span>
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean      @default(true)
  createdBy   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([productId])
  @@index([isActive])
  @@index([startDate, endDate])
  @@map("discounts")
}

<span class="cm">// â”€â”€â”€ MÃ“DULO VENTAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
model Sale {
  id              String     @id @default(uuid())
  userId          String
  user            User       @relation(fields: [userId], references: [id])
  total           Decimal    @db.Decimal(10, 2)
  status          SaleStatus @default(PENDING)
  idempotencyKey  String?    @unique
  items           SaleItem[]
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("sales")
}

model SaleItem {
  id        String  @id @default(uuid())
  saleId    String
  sale      Sale    @relation(fields: [saleId], references: [id])
  productId String
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)

  @@index([saleId])
  @@index([productId])
  @@map("sale_items")
}

<span class="cm">// â”€â”€â”€ ENUMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span>
enum Role {
  USER       <span class="cm">// acceso bÃ¡sico</span>
  ADMIN      <span class="cm">// acceso total</span>
  RRHH       <span class="cm">// gestiÃ³n de trabajadores</span>
  PRICING    <span class="cm">// gestiÃ³n de precios y descuentos</span>
}

enum WorkerStatus {
  ACTIVE     <span class="cm">// trabajando</span>
  INACTIVE   <span class="cm">// desactivado manualmente</span>
  RESIGNED   <span class="cm">// renunciÃ³</span>
}

enum MovementType {
  HIRE             <span class="cm">// ingreso inicial</span>
  RESIGN           <span class="cm">// renuncia</span>
  REACTIVATE       <span class="cm">// reingreso</span>
  POSITION_CHANGE  <span class="cm">// cambio de cargo</span>
  DEACTIVATE       <span class="cm">// desactivaciÃ³n manual</span>
}

enum StockMovementType {
  IN       <span class="cm">// entrada de stock (compra, reposiciÃ³n)</span>
  OUT      <span class="cm">// salida de stock (venta manual)</span>
  ADJUST   <span class="cm">// ajuste manual</span>
  RETURN   <span class="cm">// devoluciÃ³n</span>
}

enum SaleStatus { PENDING COMPLETED CANCELLED }</pre>
      </div>

      <h3>// 5. comandos esenciales</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal â€” comandos Prisma</span><span class="code-lang">bash</span></div>
        <pre><span class="cm"># crear la migraciÃ³n y aplicarla en la BD</span>
<span class="cm"># genera un archivo SQL en prisma/migrations/ con los cambios</span>
npx prisma migrate dev --name init

<span class="cm"># despuÃ©s de cada cambio al schema, ejecutar de nuevo:</span>
npx prisma migrate dev --name agregar-campo-descripcion

<span class="cm"># generar el cliente JS basado en el schema actual</span>
<span class="cm"># esto actualiza el autocompletado e intellisense en tu editor</span>
<span class="cm"># ejecutar siempre despuÃ©s de migrate dev</span>
npx prisma generate

<span class="cm"># abrir Prisma Studio â€” interfaz visual para ver y editar los datos</span>
npx prisma studio

<span class="cm"># aplicar migraciones en producciÃ³n (sin crear nuevas)</span>
npx prisma migrate deploy

<span class="cm"># formatear el schema.prisma</span>
npx prisma format</pre>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">migrate dev vs migrate deploy</div>
          <p><code>migrate dev</code> es para desarrollo â€” crea nuevas migraciones y las aplica. <code>migrate deploy</code> es para producciÃ³n â€” solo aplica migraciones ya existentes sin crear nuevas. Nunca uses <code>migrate dev</code> en producciÃ³n.</p>
        </div>
      </div>

      <h3>// 6. plugin â€” cliente compartido en Fastify</h3>
      <p>En Fastify necesitas crear una sola instancia del cliente Prisma y compartirla en toda la app. Si creas mÃºltiples instancias, agotas las conexiones a la base de datos.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/plugins/prisma.plugin.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import { PrismaClient } from '@prisma/client'

<span class="cm">// âœ… instancia Ãºnica â€” compartida en toda la app</span>
<span class="cm">// log: ['warn', 'error'] muestra advertencias y errores en consola</span>
<span class="cm">// en desarrollo puedes agregar 'query' para ver el SQL generado</span>
export const prisma = new PrismaClient({
  log: ['warn', 'error']
})

export const prismaPlugin = fp(async (fastify) => {
  <span class="cm">// decorate hace que fastify.prisma estÃ© disponible en toda la app</span>
  fastify.decorate('prisma', prisma)

  <span class="cm">// cuando la app se apaga, desconectar Prisma limpiamente</span>
  <span class="cm">// sin esto, el proceso Node.js no terminarÃ­a correctamente</span>
  fastify.addHook('onClose', async () => {
    await prisma.$disconnect()
  })
})</pre>
      </div>

      <h3>// 7. registrar en app.js</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>import { prismaPlugin } from './shared/plugins/prisma.plugin.js'

export function buildApp() {
  const app = Fastify({ ... })

  <span class="cm">// registrar antes que los mÃ³dulos</span>
  <span class="cm">// asÃ­ todos los mÃ³dulos pueden acceder a fastify.prisma</span>
  app.register(prismaPlugin)

  app.register(salesModule, { prefix: '/api/sales' })
  app.register(authModule,  { prefix: '/api/auth' })

  return app
}</pre>
      </div>

      <h3>// 8. cÃ³mo usar el cliente en los repositorios</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ uso en cualquier repository</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// importar la instancia compartida directamente</span>
import { prisma } from '../../shared/plugins/prisma.plugin.js'

<span class="cm">// operaciones bÃ¡sicas</span>
await prisma.sale.findMany()                          <span class="cm">// SELECT *</span>
await prisma.sale.findUnique({ where: { id } })       <span class="cm">// SELECT WHERE id = ?</span>
await prisma.sale.findFirst({ where: { userId } })    <span class="cm">// SELECT LIMIT 1</span>
await prisma.sale.create({ data: { ... } })           <span class="cm">// INSERT</span>
await prisma.sale.update({ where: { id }, data })     <span class="cm">// UPDATE</span>
await prisma.sale.delete({ where: { id } })           <span class="cm">// DELETE</span>
await prisma.sale.count({ where: { status } })        <span class="cm">// COUNT</span></pre>
      </div>

      <h3>// 9. buenas prÃ¡cticas con Prisma</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ buenas prÃ¡cticas</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âœ… usar select para no exponer campos sensibles</span>
await prisma.user.findMany({
  select: { id: true, name: true, email: true }
  <span class="cm">// password nunca se incluye en la respuesta</span>
})

<span class="cm">// âœ… usar include para traer relaciones cuando las necesitas</span>
await prisma.sale.findUnique({
  where: { id },
  include: { items: { include: { product: true } } }
})

<span class="cm">// âœ… transacciones para operaciones atÃ³micas</span>
await prisma.$transaction(async (tx) => {
  await tx.sale.create(...)
  await tx.product.update(...)
})

<span class="cm">// âœ… Promise.all para consultas independientes en paralelo</span>
const [data, total] = await Promise.all([
  prisma.sale.findMany({ ... }),
  prisma.sale.count({ ... })
])

<span class="cm">// âŒ nunca crear mÃºltiples instancias de PrismaClient</span>
<span class="cm">// agota las conexiones a la BD</span>
const prisma = new PrismaClient()  <span class="cm">// MAL â€” usar la instancia compartida</span>

<span class="cm">// âŒ nunca usar $queryRawUnsafe con datos del usuario</span>
<span class="cm">// vulnerable a SQL injection</span>
prisma.$queryRawUnsafe(`SELECT * WHERE id = '${id}'`)  <span class="cm">// MAL</span>

<span class="cm">// âœ… si necesitas SQL raw, usa el tagged template</span>
prisma.$queryRaw`SELECT * FROM sales WHERE id = ${id}`  <span class="cm">// BIEN</span></pre>
      </div>

      <h3>// 10. ver el SQL que genera Prisma (debug)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ activar logs de queries en desarrollo</span><span class="code-lang">js</span></div>
        <pre>export const prisma = new PrismaClient({
  log: [
    { emit: 'event', level: 'query' },  <span class="cm">// ver el SQL generado</span>
    'warn',
    'error'
  ]
})

<span class="cm">// escuchar eventos de query</span>
prisma.$on('query', (e) => {
  console.log('Query:', e.query)
  console.log('Params:', e.params)
  console.log('DuraciÃ³n:', e.duration + 'ms')
})

<span class="cm">// Ãºtil para detectar queries lentas o N+1 queries</span></pre>
      </div>

    </div>

    <!-- PASO 6: REPOSITORY -->
    <div class="section" id="paso-6">
      <div class="section-header">
        <div class="step-number">06</div>
        <div>
          <div class="section-title">Repository â€” Capa de Datos</div>
          <div class="section-desc">La Ãºnica capa que habla con la base de datos. Sin lÃ³gica de negocio, sin errores HTTP.</div>
        </div>
      </div>

      <p>El repository es el traductor entre tu aplicaciÃ³n y la base de datos. Sus funciones tienen nombres descriptivos de lo que hacen a nivel de datos: <code>findAll</code>, <code>findById</code>, <code>create</code>, <code>update</code>, <code>deleteById</code>. Nada mÃ¡s.</p>

      <div class="callout info">
        <span class="callout-icon">ğŸ“¦</span>
        <div>
          <div class="callout-title">Regla de oro del repository</div>
          <p>Si una funciÃ³n del repository empieza a tener <code>if</code>, validaciones o reglas de negocio, es una seÃ±al de que esa lÃ³gica deberÃ­a estar en el service. El repository solo ejecuta la query â€” el service decide si se puede ejecutar.</p>
        </div>
      </div>

      <div class="compare">
        <div class="compare-box bad">
          <div class="compare-header">âŒ LÃ³gica de negocio en el repository</div>
          <pre>async function createSale({ userId, items }) {
  // MAL â€” esto es lÃ³gica de negocio
  for (const item of items) {
    if (product.stock < item.quantity)
      throw new Error('Sin stock')
  }
  // MAL â€” el repository no deberÃ­a calcular el total
  const total = items.reduce(...)
  return prisma.sale.create(...)
}</pre>
        </div>
        <div class="compare-box good">
          <div class="compare-header">âœ… Repository solo persiste datos</div>
          <pre">async function createSale({ userId, items, total }) {
  // BIEN â€” recibe los datos ya validados y calculados
  // el service ya verificÃ³ el stock y calculÃ³ el total
  return prisma.sale.create({
    data: { userId, total, items: { create: items } }
  })
}</pre>
        </div>
      </div>

      <h3>// buenas prÃ¡cticas del repository</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.repository.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'

<span class="cm">// âœ… BUENA PRÃCTICA: usar select para exponer solo los campos necesarios</span>
<span class="cm">// Nunca devolver campos sensibles como password, tokens, etc.</span>
export async function findAllSales({ page = 1, limit = 10, status, userId } = {}) {
  const skip = (page - 1) * limit
  const where = {}
  if (status) where.status = status
  if (userId) where.userId = userId

  <span class="cm">// âœ… BUENA PRÃCTICA: Promise.all para consultas en paralelo</span>
  const [data, total] = await Promise.all([
    prisma.sale.findMany({
      where,
      skip,
      take: limit,
      include: {
        <span class="cm">// âœ… select solo los campos que el cliente necesita ver</span>
        <span class="cm">// nunca incluir password u otros datos sensibles del usuario</span>
        user:  { select: { id: true, name: true, email: true } },
        items: { include: { product: { select: { id: true, name: true, price: true } } } }
      },
      orderBy: { createdAt: 'desc' }
    }),
    prisma.sale.count({ where })
  ])

  return { data, total }
}

export async function findSaleById(id) {
  return prisma.sale.findUnique({
    where: { id },
    include: {
      user:  { select: { id: true, name: true, email: true } },
      items: { include: { product: true } }
    }
  })
}

<span class="cm">// âœ… BUENA PRÃCTICA: recibir los datos ya procesados del service</span>
<span class="cm">// total e items ya fueron calculados y validados arriba</span>
export async function createSale({ userId, items, total }) {
  return prisma.sale.create({
    data: {
      userId,
      total,
      items: { create: items }
    },
    include: { items: { include: { product: true } } }
  })
}

export async function updateSale(id, data) {
  return prisma.sale.update({
    where: { id },
    data,
    include: { items: { include: { product: true } } }
  })
}

export async function deleteById(id) {
  return prisma.sale.delete({ where: { id } })
}</pre>
      </div>

      <h3>// quÃ© NO debe hacer el repository</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ errores comunes a evitar</span><span class="code-lang">js</span></div>
        <pre"><span class="cm">// âŒ lanzar errores HTTP â€” eso es del service o el errorHandler</span>
if (!sale) throw { statusCode: 404, message: 'No encontrado' }

<span class="cm">// âŒ validar reglas de negocio</span>
if (sale.status === 'COMPLETED') throw new Error('No se puede modificar')

<span class="cm">// âŒ devolver campos sensibles sin filtrar</span>
return prisma.user.findMany()  <span class="cm">// incluye passwords!</span>

<span class="cm">// âœ… en cambio, siempre usar select para campos sensibles</span>
return prisma.user.findMany({
  select: { id: true, name: true, email: true, role: true }
  <span class="cm">// password nunca se incluye</span>
})</pre>
      </div>

    </div>

    <!-- PASO 7: SERVICE -->
    <div class="section" id="paso-7">
      <div class="section-header">
        <div class="step-number">07</div>
        <div>
          <div class="section-title">Service â€” LÃ³gica de Negocio</div>
          <div class="section-desc">El cerebro del mÃ³dulo. Decide si la operaciÃ³n puede ejecutarse, coordina repositorios y ejecuta transacciones.</div>
        </div>
      </div>

      <p>El service es quien tiene el conocimiento del negocio. Sabe que no puedes vender mÃ¡s stock del que hay, que solo el dueÃ±o puede modificar su venta, que una venta completada no se puede cancelar. Esas reglas no las conoce nadie mÃ¡s.</p>

      <div class="grid-2">
        <div class="card">
          <h4>âœ… SÃ­ va en el service</h4>
          <p>Verificar stock antes de vender. Calcular totales. Verificar permisos de negocio. Coordinar mÃºltiples repositorios. Ejecutar transacciones atÃ³micas.</p>
        </div>
        <div class="card">
          <h4>âŒ No va en el service</h4>
          <p>Leer <code>request.body</code> o <code>request.params</code>. Devolver <code>reply.send()</code>. Validar formato de datos (eso es del schema). Ejecutar queries directas sin lÃ³gica.</p>
        </div>
      </div>

      <div class="callout info">
        <span class="callout-icon">âš™ï¸</span>
        <div>
          <div class="callout-title">Â¿CuÃ¡ndo usar una transacciÃ³n?</div>
          <p>Cuando la operaciÃ³n toca mÃºltiples tablas y debe ser todo o nada. Si algo falla en medio, Prisma revierte todo automÃ¡ticamente. Ejemplo: crear venta + descontar stock. Si el descuento falla, la venta no debe crearse.</p>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.service.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'
import { findAllSales, findSaleById, updateSale, deleteById } from './sales.repository.js'
import { buildPagination } from '../../shared/utils/pagination.js'

export async function getAllSales({ page, limit, status, userId }) {
  const { data, total } = await findAllSales({ page, limit, status, userId })
  return buildPagination(data, total, page, limit)
}

export async function getSaleById(id) {
  const sale = await findSaleById(id)

  <span class="cm">// regla: la venta debe existir</span>
  if (!sale) {
    const err = new Error('Venta no encontrada')
    err.statusCode = 404
    throw err
  }
  return sale
}

export async function createSale({ userId, items }) {
  <span class="cm">// transacciÃ³n: todo o nada â€” si algo falla, nada se guarda</span>
  return prisma.$transaction(async (tx) => {
    let total = 0
    const saleItems = []

    for (const item of items) {
      const product = await tx.product.findUnique({ where: { id: item.productId } })

      <span class="cm">// regla 1: el producto debe existir</span>
      if (!product) {
        const err = new Error(`Producto ${item.productId} no existe`)
        err.statusCode = 404
        throw err
      }

      <span class="cm">// regla 2: debe haber suficiente stock</span>
      if (product.stock < item.quantity) {
        const err = new Error(`Stock insuficiente para "${product.name}". Disponible: ${product.stock}`)
        err.statusCode = 409
        throw err
      }

      <span class="cm">// calcular precio y acumular total</span>
      const unitPrice = Number(product.price)
      total += unitPrice * item.quantity
      saleItems.push({ productId: item.productId, quantity: item.quantity, unitPrice })
    }

    <span class="cm">// crear la venta con el total calculado</span>
    const sale = await tx.sale.create({
      data: { userId, total, items: { create: saleItems } },
      include: { items: { include: { product: true } } }
    })

    <span class="cm">// descontar stock â€” atÃ³mico con la creaciÃ³n de la venta</span>
    for (const item of items) {
      await tx.product.update({
        where: { id: item.productId },
        data: { stock: { decrement: item.quantity } }
      })
    }

    return sale
  })
}

export async function updateSaleStatus(id, data, requestUser) {
  const sale = await findSaleById(id)

  <span class="cm">// regla 1: la venta debe existir</span>
  if (!sale) {
    const err = new Error('Venta no encontrada')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// regla 2: solo el dueÃ±o o un admin puede modificar</span>
  if (sale.userId !== requestUser.id && requestUser.role !== 'ADMIN') {
    const err = new Error('No tienes permiso para modificar esta venta')
    err.statusCode = 403
    throw err
  }

  <span class="cm">// regla 3: una venta completada no se puede modificar</span>
  if (sale.status === 'COMPLETED') {
    const err = new Error('No se puede modificar una venta completada')
    err.statusCode = 409
    throw err
  }

  return updateSale(id, data)
}

export async function removeSale(id, requestUser) {
  const sale = await findSaleById(id)

  if (!sale) {
    const err = new Error('Venta no encontrada')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// regla: solo admin puede eliminar ventas</span>
  if (requestUser.role !== 'ADMIN') {
    const err = new Error('Solo administradores pueden eliminar ventas')
    err.statusCode = 403
    throw err
  }

  return deleteById(id)
}</pre>
      </div>

      <h3>// buenas prÃ¡cticas de seguridad en el service</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prÃ¡cticas recomendadas</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âœ… 1. siempre verificar que el recurso existe antes de operar</span>
const sale = await findSaleById(id)
if (!sale) { err.statusCode = 404; throw err }

<span class="cm">// âœ… 2. verificar propiedad del recurso â€” no solo autenticaciÃ³n</span>
if (sale.userId !== requestUser.id && requestUser.role !== 'ADMIN') {
  err.statusCode = 403; throw err
}

<span class="cm">// âœ… 3. usar transacciones para operaciones que tocan varias tablas</span>
await prisma.$transaction(async (tx) => { ... })

<span class="cm">// âœ… 4. errores descriptivos para el cliente pero sin exponer internos</span>
const err = new Error('Stock insuficiente para "Laptop". Disponible: 3')
<span class="cm">// âŒ nunca: new Error('Prisma error P2002 at constraint...')</span>

<span class="cm">// âœ… 5. un service puede usar repositories de otros mÃ³dulos</span>
<span class="cm">// si necesitas datos de productos en el service de ventas, impÃ³rtalos</span>
import { findProductById } from '../products/products.repository.js'</pre>
      </div>

    </div>

    <!-- PASO 8: CONTROLLER -->
    <div class="section" id="paso-8">
      <div class="section-header">
        <div class="step-number">08</div>
        <div>
          <div class="section-title">Controller â€” Capa HTTP</div>
          <div class="section-desc">Extrae datos del request, ejecuta el schema, llama al service y devuelve la respuesta HTTP.</div>
        </div>
      </div>

      <p>El controller es el intermediario entre el mundo HTTP y el service. Sabe leer un <code>request</code> y escribir un <code>reply</code>, pero no sabe nada de reglas de negocio. Si el controller empieza a tener <code>if</code> con lÃ³gica de negocio, es una seÃ±al de que esa lÃ³gica deberÃ­a estar en el service.</p>

      <h3>// quÃ© extrae el controller de cada peticiÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ partes del request que usa el controller</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// request.params â†’ variables en la URL</span>
<span class="cm">// GET /api/sales/123 â†’ request.params.id = "123"</span>

<span class="cm">// request.query â†’ parÃ¡metros de bÃºsqueda en la URL</span>
<span class="cm">// GET /api/sales?page=2&status=PENDING â†’ request.query = { page: "2", status: "PENDING" }</span>

<span class="cm">// request.body â†’ datos del POST/PATCH</span>
<span class="cm">// POST /api/sales con { items: [...] } â†’ request.body.items</span>

<span class="cm">// request.user â†’ datos del token JWT (lo pone requireAuth)</span>
<span class="cm">// { id: "abc-123", email: "juan@mail.com", role: "USER" }</span></pre>
      </div>

      <h3>// cÃ³digos HTTP correctos por operaciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ referencia de status codes</span><span class="code-lang">bash</span></div>
        <pre">GET    â†’ 200 OK              (devuelve datos)
POST   â†’ 201 Created         (recurso creado)
PATCH  â†’ 200 OK              (recurso actualizado)
DELETE â†’ 204 No Content      (eliminado, sin body)
Error  â†’ 400/401/403/404/409 (manejados por errorHandler)</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.controller.js</span><span class="code-lang">js</span></div>
        <pre>import { getAllSales, getSaleById, createSale, updateSaleStatus, removeSale } from './sales.service.js'
import { getSalesQuerySchema, createSaleSchema, updateSaleSchema } from './sales.schema.js'
import { sanitizeQuery } from '../../shared/utils/sanitize.js'

export async function listSalesHandler(request, reply) {
  <span class="cm">// 1. sanitizar y validar query params</span>
  const query = getSalesQuerySchema.parse(sanitizeQuery(request.query))

  <span class="cm">// 2. restricciÃ³n de visibilidad segÃºn rol</span>
  <span class="cm">// esta lÃ³gica va aquÃ­ porque depende de request.user (HTTP)</span>
  if (request.user.role !== 'ADMIN') {
    query.userId = request.user.id  <span class="cm">// USER solo ve sus ventas</span>
  }

  <span class="cm">// 3. llamar al service y devolver resultado</span>
  const result = await getAllSales(query)
  return reply.send(result)  <span class="cm">// 200 OK por defecto</span>
}

export async function getSaleHandler(request, reply) {
  <span class="cm">// params.id viene de la URL: GET /api/sales/abc-123</span>
  const sale = await getSaleById(request.params.id)
  return reply.send(sale)
}

export async function createSaleHandler(request, reply) {
  <span class="cm">// 1. validar body con Zod â€” lanza ZodError si algo falla</span>
  const body = createSaleSchema.parse(request.body)

  <span class="cm">// 2. llamar al service con los datos del usuario autenticado</span>
  const sale = await createSale({ userId: request.user.id, items: body.items })

  <span class="cm">// 3. 201 Created â€” se creÃ³ un nuevo recurso</span>
  return reply.code(201).send(sale)
}

export async function updateSaleHandler(request, reply) {
  const body = updateSaleSchema.parse(request.body)
  const sale = await updateSaleStatus(request.params.id, body, request.user)
  return reply.send(sale)  <span class="cm">// 200 OK</span>
}

export async function deleteSaleHandler(request, reply) {
  await removeSale(request.params.id, request.user)
  return reply.code(204).send()  <span class="cm">// 204 No Content â€” sin body</span>
}</pre>
      </div>

      <div class="compare">
        <div class="compare-box bad">
          <div class="compare-header">âŒ LÃ³gica de negocio en el controller</div>
          <pre>export async function createSaleHandler(request, reply) {
  // MAL â€” verificar stock aquÃ­ estÃ¡ FUERA de lugar
  for (const item of request.body.items) {
    const product = await prisma.product.findUnique(...)
    if (product.stock < item.quantity)
      return reply.code(409).send({ message: 'Sin stock' })
  }
  // MAL â€” acceder a prisma directamente desde el controller
  const sale = await prisma.sale.create(...)
}</pre>
        </div>
        <div class="compare-box good">
          <div class="compare-header">âœ… Controller limpio y simple</div>
          <pre>export async function createSaleHandler(request, reply) {
  // BIEN â€” solo valida, llama al service y responde
  const body = createSaleSchema.parse(request.body)
  const sale = await createSale({
    userId: request.user.id,
    items: body.items
  })
  return reply.code(201).send(sale)
}</pre>
        </div>
      </div>

    </div>

    <!-- PASO 9: ROUTES + SCHEMA -->
    <div class="section" id="paso-9">
      <div class="section-header">
        <div class="step-number">09</div>
        <div>
          <div class="section-title">Routes + Schemas Zod</div>
          <div class="section-desc">Routes define URLs, mÃ©todos, middlewares y conectan con el controller. Schemas validan los datos de entrada.</div>
        </div>
      </div>

      <p>Routes tiene 3 responsabilidades claras:</p>
      <div class="grid-2">
        <div class="card">
          <h4>ğŸ”— Lo que hace Routes</h4>
          <p><strong>1.</strong> Define la URL y el mÃ©todo HTTP (GET, POST, PATCH, DELETE).<br><strong>2.</strong> Asigna los middlewares de seguridad en <code>preHandler</code>.<br><strong>3.</strong> Conecta con el handler del controller.</p>
        </div>
        <div class="card">
          <h4>ğŸ“‹ Lo que hace Schema</h4>
          <p>Define la forma exacta que deben tener los datos de entrada. Si el body no cumple el schema, Zod lanza un error que el errorHandler convierte en un 400 automÃ¡ticamente.</p>
        </div>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">Schema se define aquÃ­, se ejecuta en el controller</div>
          <p>Routes especifica quÃ© schema usar para cada ruta. El controller es quien llama a <code>schema.parse()</code> y lo ejecuta realmente. La separaciÃ³n permite reutilizar el mismo schema en diferentes lugares si fuera necesario.</p>
        </div>
      </div>

      <h3>// schemas Zod â€” validaciÃ³n de entrada</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.schema.js</span><span class="code-lang">js</span></div>
        <pre>import { z } from 'zod'

<span class="cm">// schema para crear una venta</span>
<span class="cm">// valida que el body tenga al menos un item con productId (UUID) y quantity (nÃºmero positivo)</span>
export const createSaleSchema = z.object({
  items: z.array(z.object({
    productId: z.string().uuid('ID de producto invÃ¡lido'),
    quantity:  z.number().int().positive('La cantidad debe ser mayor a 0')
  })).min(1, 'Debes incluir al menos un producto')
})

<span class="cm">// schema para actualizar estado</span>
<span class="cm">// solo acepta uno de estos 3 valores exactos â€” nada mÃ¡s pasa</span>
export const updateSaleSchema = z.object({
  status: z.enum(['PENDING', 'COMPLETED', 'CANCELLED'])
})

<span class="cm">// schema para query params de listado</span>
<span class="cm">// coerce convierte el string de la URL a nÃºmero automÃ¡ticamente</span>
export const getSalesQuerySchema = z.object({
  page:   z.coerce.number().int().positive().default(1),
  limit:  z.coerce.number().int().positive().max(100).default(10),
  status: z.enum(['PENDING', 'COMPLETED', 'CANCELLED']).optional(),
  userId: z.string().uuid().optional()
})

<span class="cm">// si el body no cumple el schema, Zod lanza un ZodError</span>
<span class="cm">// el errorHandler lo captura y devuelve un 400 con los campos invÃ¡lidos</span></pre>
      </div>

      <h3>// quÃ© pasa cuando el schema falla</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ respuesta cuando el body es invÃ¡lido</span><span class="code-lang">json</span></div>
        <pre">{
  "statusCode": 400,
  "error": "Validation Error",
  "message": "Datos invÃ¡lidos",
  "details": [
    { "field": "items.0.productId", "message": "ID de producto invÃ¡lido" },
    { "field": "items.0.quantity",  "message": "La cantidad debe ser mayor a 0" }
  ]
}</pre>
      </div>

      <h3>// routes â€” tabla de instrucciones de Fastify</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.routes.js</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { requireRole } from '../../shared/middlewares/roles.middleware.js'
import {
  listSalesHandler,
  getSaleHandler,
  createSaleHandler,
  updateSaleHandler,
  deleteSaleHandler
} from './sales.controller.js'

export async function salesRoutes(fastify) {

  <span class="cm">// GET /api/sales â€” cualquier usuario autenticado</span>
  <span class="cm">// preHandler ejecuta requireAuth ANTES del handler</span>
  fastify.get('/', {
    preHandler: [requireAuth],
    schema: { tags: ['Sales'], summary: 'Listar ventas con paginaciÃ³n', security: [{ bearerAuth: [] }] }
  }, listSalesHandler)

  <span class="cm">// GET /api/sales/:id â€” el :id es un parÃ¡metro dinÃ¡mico</span>
  <span class="cm">// llega al controller como request.params.id</span>
  fastify.get('/:id', {
    preHandler: [requireAuth],
    schema: { tags: ['Sales'], summary: 'Obtener venta por ID' }
  }, getSaleHandler)

  <span class="cm">// POST /api/sales â€” crear venta</span>
  <span class="cm">// el body llega al controller como request.body</span>
  fastify.post('/', {
    preHandler: [requireAuth],
    schema: { tags: ['Sales'], summary: 'Crear nueva venta' }
  }, createSaleHandler)

  <span class="cm">// PATCH /api/sales/:id â€” actualizar estado</span>
  <span class="cm">// PATCH es para actualizaciones parciales, PUT es para reemplazos completos</span>
  fastify.patch('/:id', {
    preHandler: [requireAuth],
    schema: { tags: ['Sales'], summary: 'Actualizar estado de venta' }
  }, updateSaleHandler)

  <span class="cm">// DELETE /api/sales/:id â€” solo ADMIN</span>
  <span class="cm">// preHandler ejecuta requireAuth primero, luego requireRole</span>
  <span class="cm">// si requireAuth falla â†’ 401. Si requireRole falla â†’ 403</span>
  <span class="cm">// el handler nunca llega a ejecutarse si alguno falla</span>
  fastify.delete('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Sales'], summary: 'Eliminar venta (solo admin)' }
  }, deleteSaleHandler)
}</pre>
      </div>

      <h3>// flujo completo de una peticiÃ³n por las 4 capas</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ DELETE /api/sales/abc-123 â€” paso a paso</span><span class="code-lang">bash</span></div>
        <pre>ROUTES        â†’ Fastify recibe DELETE /api/sales/abc-123
              â†’ ejecuta preHandler: requireAuth â†’ verifica JWT â†’ request.user = { id, role }
              â†’ ejecuta preHandler: requireRole('ADMIN') â†’ verifica role
              â†’ llama a deleteSaleHandler

CONTROLLER    â†’ extrae request.params.id = "abc-123"
              â†’ extrae request.user = { id: "xyz", role: "ADMIN" }
              â†’ llama a removeSale("abc-123", request.user)

SERVICE       â†’ llama a findSaleById("abc-123") â†’ verifica que existe
              â†’ verifica que requestUser.role === 'ADMIN'
              â†’ llama a deleteById("abc-123")

REPOSITORY    â†’ prisma.sale.delete({ where: { id: "abc-123" } })
              â†’ devuelve el registro eliminado

CONTROLLER    â†’ recibe el resultado del service
              â†’ reply.code(204).send() â†’ responde al cliente sin body</pre>
      </div>

    </div>

    <!-- PASO 10: MÃ“DULO -->
    <div class="section" id="paso-10">
      <div class="section-header">
        <div class="step-number">10</div>
        <div>
          <div class="section-title">MÃ³dulo â€” Plugin de Fastify</div>
          <div class="section-desc">El puente entre tu mÃ³dulo y Fastify. Sin Ã©l, las rutas no existen para la app.</div>
        </div>
      </div>

      <p>Cuando creas las rutas de ventas en <code>sales.routes.js</code>, Fastify todavÃ­a no sabe que existen. El <code>sales.module.js</code> es quien le dice a Fastify: <strong>"registra estas rutas y hazlas disponibles"</strong>. Sin este archivo, podrÃ­as tener todo el cÃ³digo perfecto pero ningÃºn endpoint responderÃ­a.</p>

      <h3>// por quÃ© necesitas este archivo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ sin sales.module.js â€” las rutas no existen</span><span class="code-lang">bash</span></div>
        <pre>GET /api/sales     â†’ 404 Not Found  âŒ
POST /api/sales    â†’ 404 Not Found  âŒ
DELETE /api/sales  â†’ 404 Not Found  âŒ

// Fastify no sabe que existen porque nadie las registrÃ³</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ con sales.module.js â€” las rutas funcionan</span><span class="code-lang">bash</span></div>
        <pre>GET /api/sales     â†’ 200 OK  âœ…
POST /api/sales    â†’ 201 Created  âœ…
DELETE /api/sales  â†’ 204 No Content  âœ…

// Fastify las conoce porque el mÃ³dulo las registrÃ³</pre>
      </div>

      <h3>// quÃ© hace fp() â€” fastify-plugin</h3>
      <p>Sin <code>fp()</code>, cada plugin vive en su propio scope aislado y no puede ver los plugins del padre como <code>prisma</code>, <code>redis</code> o <code>jwt</code>. Con <code>fp()</code> el mÃ³dulo comparte el mismo scope que <code>app.js</code> y puede acceder a todo.</p>

      <div class="compare">
        <div class="compare-box bad">
          <div class="compare-header">âŒ Sin fp() â€” scope aislado</div>
          <pre>// sales.routes.js no puede acceder
// a fastify.prisma ni fastify.redis
// porque estÃ¡n en un scope diferente

export const salesModule = async (fastify) => {
  fastify.register(salesRoutes)
  // salesRoutes no ve prisma ni redis âŒ
}</pre>
        </div>
        <div class="compare-box good">
          <div class="compare-header">âœ… Con fp() â€” scope compartido</div>
          <pre">// sales.routes.js puede acceder
// a fastify.prisma, fastify.redis, fastify.jwt
// porque comparte el scope de app.js

export const salesModule = fp(async (fastify) => {
  fastify.register(salesRoutes)
  // salesRoutes ve todo âœ…
})</pre>
        </div>
      </div>

      <h3>// el archivo completo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.module.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import { salesRoutes } from './sales.routes.js'

<span class="cm">// fp() envuelve el plugin para compartir el scope con app.js</span>
export const salesModule = fp(async (fastify) => {
  <span class="cm">// registra todas las rutas de ventas en Fastify</span>
  <span class="cm">// a partir de aquÃ­ GET /api/sales, POST /api/sales, etc. existen</span>
  fastify.register(salesRoutes)
})</pre>
      </div>

      <h3>// dÃ³nde se llama â€” en app.js</h3>
      <p>Cada mÃ³dulo se registra en <code>app.js</code> con un prefijo. Ese prefijo se antepone automÃ¡ticamente a todas las rutas del mÃ³dulo.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>import { authModule }     from './modules/auth/auth.module.js'
import { salesModule }    from './modules/sales/sales.module.js'
import { productsModule } from './modules/products/products.module.js'

export function buildApp() {
  const app = Fastify({ ... })

  <span class="cm">// prefix define la URL base de cada mÃ³dulo</span>
  app.register(authModule,     { prefix: '/api/auth' })
  app.register(salesModule,    { prefix: '/api/sales' })
  app.register(productsModule, { prefix: '/api/products' })

  return app
}

<span class="cm">// las rutas quedan disponibles como:</span>
<span class="cm">// /api/auth/login       â†’ authModule</span>
<span class="cm">// /api/auth/register    â†’ authModule</span>
<span class="cm">// /api/sales            â†’ salesModule</span>
<span class="cm">// /api/sales/:id        â†’ salesModule</span>
<span class="cm">// /api/products         â†’ productsModule</span></pre>
      </div>

      <h3>// cÃ³mo crear un nuevo mÃ³dulo desde cero</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ ejemplo â€” agregar mÃ³dulo de Ã³rdenes</span><span class="code-lang">bash</span></div>
        <pre">1. Crear la carpeta y archivos:
   src/modules/orders/
   â”œâ”€â”€ orders.module.js      â† el plugin
   â”œâ”€â”€ orders.routes.js      â† rutas
   â”œâ”€â”€ orders.controller.js  â† HTTP
   â”œâ”€â”€ orders.service.js     â† negocio
   â”œâ”€â”€ orders.repository.js  â† datos
   â””â”€â”€ orders.schema.js      â† validaciÃ³n

2. Registrar en app.js:
   app.register(ordersModule, { prefix: '/api/orders' })

3. Listo â€” /api/orders ya responde</pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">âœ…</span>
        <div>
          <div class="callout-title">Cada mÃ³dulo es independiente</div>
          <p>Agregar el mÃ³dulo de Ã³rdenes no toca nada del mÃ³dulo de ventas ni de productos. Cada mÃ³dulo vive en su carpeta, tiene sus propias 4 capas, y solo se conecta a la app a travÃ©s de <code>app.js</code>.</p>
        </div>
      </div>

    </div>

    <!-- PASO 11: ARCHIVOS -->
    <div class="section" id="paso-11">
      <div class="section-header">
        <div class="step-number">11</div>
        <div>
          <div class="section-title">Subida de Archivos</div>
          <div class="section-desc">Upload seguro de imÃ¡genes con UUID, validaciÃ³n de tipo y tamaÃ±o.</div>
        </div>
      </div>

      <p>Cuando un usuario sube un archivo, el nombre original que trae es peligroso â€” puede contener rutas relativas, caracteres especiales o extensiones maliciosas. La soluciÃ³n es descartar el nombre original y generar uno nuevo con UUID, conservando solo la extensiÃ³n.</p>

      <div class="compare">
        <div class="compare-box bad">
          <div class="compare-header">âŒ Nombre original â€” peligroso</div>
          <pre>data.filename = "../../etc/passwd"
data.filename = "malware.exe"
data.filename = "foto bonita.jpg"
data.filename = "imagen'con;caracteres.png"

// cualquiera de estos puede causar problemas</pre>
        </div>
        <div class="compare-box good">
          <div class="compare-header">âœ… Nombre con UUID â€” seguro</div>
          <pre>// UUID + extensiÃ³n original validada
"550e8400-e29b-41d4-a716-446655440000.jpg"
"f47ac10b-58cc-4372-a567-0e02b2c3d479.png"
"6ba7b810-9dad-11d1-80b4-00c04fd430c8.webp"

// imposible de predecir o colisionar</pre>
        </div>
      </div>

      <h3>// 1. instalaciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npm install @fastify/multipart @fastify/static</pre>
      </div>

      <h3>// 2. registrar multipart en app.js</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>import multipart from '@fastify/multipart'
import fastifyStatic from '@fastify/static'
import path from 'path'
import { env } from './config/env.js'

export function buildApp() {
  const app = Fastify({ ... })

  <span class="cm">// habilitar subida de archivos</span>
  app.register(multipart, {
    limits: {
      fileSize: Number(env.MAX_FILE_SIZE),  <span class="cm">// mÃ¡ximo 5MB por defecto</span>
      files: 1                               <span class="cm">// solo un archivo por peticiÃ³n</span>
    }
  })

  <span class="cm">// servir archivos estÃ¡ticos desde la carpeta uploads</span>
  <span class="cm">// asÃ­ GET /uploads/archivo.jpg devuelve la imagen</span>
  app.register(fastifyStatic, {
    root: path.resolve(env.UPLOAD_DIR),
    prefix: '/uploads/'
  })

  return app
}</pre>
      </div>

      <h3>// 3. utilidad para generar nombres seguros</h3>
      <p>UUID viene incluido en Node.js â€” no necesitas instalar nada extra.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/utils/file.utils.js</span><span class="code-lang">js</span></div>
        <pre>import { randomUUID } from 'crypto'  <span class="cm">// incluido en Node.js, sin instalaciÃ³n</span>
import path from 'path'

<span class="cm">// extensiones permitidas por tipo de uso</span>
const ALLOWED_IMAGE_TYPES = {
  'image/jpeg': '.jpg',
  'image/png':  '.png',
  'image/webp': '.webp',
}

<span class="cm">// genera un nombre seguro con UUID + extensiÃ³n validada</span>
export function generateSafeFilename(mimetype) {
  const ext = ALLOWED_IMAGE_TYPES[mimetype]
  if (!ext) return null  <span class="cm">// tipo no permitido</span>

  const uuid = randomUUID()  <span class="cm">// ej: "550e8400-e29b-41d4-a716-446655440000"</span>
  return `${uuid}${ext}`     <span class="cm">// ej: "550e8400-e29b-41d4-a716-446655440000.jpg"</span>
}

<span class="cm">// valida que el tipo MIME sea permitido</span>
export function isAllowedImageType(mimetype) {
  return mimetype in ALLOWED_IMAGE_TYPES
}

<span class="cm">// NO uses path.extname(data.filename) para obtener la extensiÃ³n</span>
<span class="cm">// un atacante puede enviar un archivo con extensiÃ³n falsa</span>
<span class="cm">// siempre deriva la extensiÃ³n del mimetype, no del nombre original</span></pre>
      </div>

      <h3>// 4. controller â€” implementaciÃ³n completa</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.controller.js</span><span class="code-lang">js</span></div>
        <pre>import path from 'path'
import fs from 'fs/promises'
import { pipeline } from 'stream/promises'
import { createWriteStream } from 'fs'
import { prisma } from '../../shared/plugins/prisma.plugin.js'
import { env } from '../../config/env.js'
import { generateSafeFilename, isAllowedImageType } from '../../shared/utils/file.utils.js'

export async function uploadProductImageHandler(request, reply) {
  <span class="cm">// obtener el archivo de la peticiÃ³n multipart</span>
  const data = await request.file()

  if (!data) {
    return reply.code(400).send({ message: 'No se enviÃ³ ningÃºn archivo' })
  }

  <span class="cm">// validar tipo MIME â€” derivado del archivo, no del nombre</span>
  if (!isAllowedImageType(data.mimetype)) {
    return reply.code(400).send({
      message: 'Tipo de archivo no permitido. Solo JPEG, PNG o WebP'
    })
  }

  <span class="cm">// generar nombre seguro con UUID + extensiÃ³n del mimetype</span>
  const filename = generateSafeFilename(data.mimetype)
  <span class="cm">// ej: "550e8400-e29b-41d4-a716-446655440000.jpg"</span>

  <span class="cm">// ruta absoluta donde se guardarÃ¡ fÃ­sicamente</span>
  const filepath = path.join(env.UPLOAD_DIR, filename)

  <span class="cm">// crear la carpeta uploads si no existe</span>
  await fs.mkdir(env.UPLOAD_DIR, { recursive: true })

  <span class="cm">// guardar el archivo en disco usando streams</span>
  <span class="cm">// pipeline maneja errores y cierra el stream correctamente</span>
  await pipeline(data.file, createWriteStream(filepath))

  <span class="cm">// URL pÃºblica accesible desde el frontend</span>
  const imageUrl = `/uploads/${filename}`

  <span class="cm">// guardar la URL en la base de datos</span>
  const product = await prisma.product.update({
    where: { id: request.params.id },
    data: { imageUrl }
  })

  request.log.info(
    { productId: request.params.id, filename, size: data.file.bytesRead },
    'Imagen de producto subida'
  )

  return reply.send({ imageUrl, product })
}</pre>
      </div>

      <h3>// 5. ruta para el upload</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.routes.js (fragmento)</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { requireRole } from '../../shared/middlewares/roles.middleware.js'
import { uploadProductImageHandler } from './products.controller.js'

export async function productsRoutes(fastify) {

  <span class="cm">// POST /api/products/:id/upload â€” solo ADMIN puede subir imÃ¡genes</span>
  fastify.post('/:id/upload', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: {
      tags: ['Products'],
      summary: 'Subir imagen de producto',
      consumes: ['multipart/form-data']
    }
  }, uploadProductImageHandler)
}</pre>
      </div>

      <h3>// 6. cÃ³mo enviarlo desde el frontend</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ frontend â€” subir imagen</span><span class="code-lang">js</span></div>
        <pre">async function uploadImage(productId, file) {
  const formData = new FormData()
  formData.append('file', file)  <span class="cm">// el archivo del input type="file"</span>

  const res = await fetch(`http://localhost:3000/api/products/${productId}/upload`, {
    method: 'POST',
    headers: {
      <span class="cm">// NO pongas Content-Type aquÃ­ â€” el navegador lo pone automÃ¡ticamente</span>
      <span class="cm">// con el boundary correcto para multipart/form-data</span>
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    },
    body: formData
  })

  const { imageUrl } = await res.json()
  console.log('Imagen subida:', imageUrl)
  <span class="cm">// imageUrl = "/uploads/550e8400-e29b-41d4-a716-446655440000.jpg"</span>
  <span class="cm">// accesible en: http://localhost:3000/uploads/550e8400...jpg</span>
}</pre>
      </div>

      <div class="callout danger">
        <span class="callout-icon">ğŸš¨</span>
        <div>
          <div class="callout-title">Nunca derives la extensiÃ³n del nombre original</div>
          <p>Un atacante puede renombrar un ejecutable como <code>foto.jpg</code> y enviarlo. Siempre usa el <strong>mimetype</strong> para determinar la extensiÃ³n real â€” el mimetype lo verifica el servidor, no el cliente.</p>
        </div>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">En producciÃ³n usa almacenamiento en la nube</div>
          <p>Guardar archivos en el disco del servidor funciona en desarrollo pero no escala bien. En producciÃ³n usa servicios como <strong>AWS S3</strong>, <strong>Cloudinary</strong> o <strong>Supabase Storage</strong> para almacenar los archivos y guardar solo la URL en PostgreSQL.</p>
        </div>
      </div>

    </div>

    <!-- PASO 12: AUTH -->
    <div class="section" id="paso-12">
      <div class="section-header">
        <div class="step-number">12</div>
        <div>
          <div class="section-title">AutenticaciÃ³n con JWT</div>
          <div class="section-desc">CÃ³mo funciona el token, dÃ³nde vive, cÃ³mo fluye entre frontend y backend.</div>
        </div>
      </div>

      <p>JWT (JSON Web Token) es un token firmado digitalmente que el servidor entrega al cliente despuÃ©s del login. El cliente lo guarda y lo envÃ­a en cada peticiÃ³n para probar su identidad. El servidor solo necesita verificar la firma â€” no guarda nada en memoria.</p>

      <h3>// flujo completo de autenticaciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ flujo JWT de punta a punta</span><span class="code-lang">bash</span></div>
        <pre>1. Usuario envÃ­a credenciales al backend
   POST /api/auth/login
   { email: "juan@mail.com", password: "12345" }

2. Backend verifica credenciales y crea el token
   token = jwt.sign({ id, email, role })
   responde: { user: {...}, token: "eyJhbG..." }

3. Frontend guarda el token
   localStorage.setItem('token', "eyJhbG...")

4. En cada peticiÃ³n siguiente, el frontend envÃ­a el token
   GET /api/sales
   Authorization: Bearer eyJhbG...

5. Backend verifica el token con requireAuth
   jwt.verify(token, JWT_SECRET) â†’ { id, email, role }
   request.user = { id, email, role }

6. Si el token es vÃ¡lido â†’ continÃºa al controller
   Si el token expirÃ³ o es invÃ¡lido â†’ 401 Unauthorized</pre>
      </div>

      <h3>// 1. instalaciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npm install @fastify/jwt bcryptjs</pre>
      </div>

      <h3>// 2. plugin JWT en el backend</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/plugins/jwt.plugin.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import fastifyJwt from '@fastify/jwt'
import { env } from '../../config/env.js'

export const jwtPlugin = fp(async (fastify) => {
  fastify.register(fastifyJwt, {
    secret: env.JWT_SECRET,          <span class="cm">// clave secreta para firmar tokens</span>
    sign: { expiresIn: env.JWT_EXPIRES_IN }  <span class="cm">// cuÃ¡nto tiempo dura el token</span>
  })
})

<span class="cm">// se registra en app.js y queda disponible como:</span>
<span class="cm">// fastify.jwt.sign()   â†’ crear token</span>
<span class="cm">// request.jwtVerify() â†’ verificar token</span></pre>
      </div>

      <h3>// 3. auth service â€” registro y login</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/auth/auth.service.js</span><span class="code-lang">js</span></div>
        <pre>import bcrypt from 'bcryptjs'
import { prisma } from '../../shared/plugins/prisma.plugin.js'

export async function registerUser({ name, email, password }, fastify) {
  <span class="cm">// verificar que el email no estÃ© registrado</span>
  const existing = await prisma.user.findUnique({ where: { email } })
  if (existing) {
    const err = new Error('El email ya estÃ¡ registrado')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// nunca guardar la contraseÃ±a en texto plano</span>
  <span class="cm">// bcrypt la convierte en un hash irreversible</span>
  const hashed = await bcrypt.hash(password, 12)
  const user = await prisma.user.create({
    data: { name, email, password: hashed },
    select: { id: true, name: true, email: true, role: true }
  })

  <span class="cm">// crear el token con los datos del usuario</span>
  const token = fastify.jwt.sign({ id: user.id, email: user.email, role: user.role })
  return { user, token }
}

export async function loginUser({ email, password }, fastify) {
  const user = await prisma.user.findUnique({ where: { email } })

  <span class="cm">// bcrypt.compare usa tiempo constante â€” previene timing attacks</span>
  <span class="cm">// si el usuario no existe, igual ejecuta el compare para no dar pistas</span>
  const valid = user && await bcrypt.compare(password, user.password)
  if (!valid) {
    const err = new Error('Credenciales invÃ¡lidas')
    err.statusCode = 401
    throw err
  }

  const token = fastify.jwt.sign({
    id:    user.id,
    email: user.email,
    role:  user.role
  })

  return {
    user: { id: user.id, name: user.name, email: user.email, role: user.role },
    token  <span class="cm">// â† el frontend guarda este token</span>
  }
}</pre>
      </div>

      <h3>// 4. auth controller y rutas</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/auth/auth.controller.js</span><span class="code-lang">js</span></div>
        <pre>import { registerUser, loginUser } from './auth.service.js'
import { registerSchema, loginSchema } from './auth.schema.js'

export async function registerHandler(request, reply) {
  const body = registerSchema.parse(request.body)
  const result = await registerUser(body, request.server)
  return reply.code(201).send(result)
}

export async function loginHandler(request, reply) {
  const body = loginSchema.parse(request.body)
  const result = await loginUser(body, request.server)
  return reply.send(result)
}

export async function getMeHandler(request, reply) {
  <span class="cm">// request.user ya tiene los datos del token gracias a requireAuth</span>
  return reply.send({ user: request.user })
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/auth/auth.routes.js</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { registerHandler, loginHandler, getMeHandler } from './auth.controller.js'

export async function authRoutes(fastify) {

  <span class="cm">// POST /api/auth/register â€” pÃºblico, no requiere token</span>
  fastify.post('/register', {
    schema: { tags: ['Auth'], summary: 'Registrar usuario' }
  }, registerHandler)

  <span class="cm">// POST /api/auth/login â€” pÃºblico, devuelve el token</span>
  fastify.post('/login', {
    schema: { tags: ['Auth'], summary: 'Iniciar sesiÃ³n' }
  }, loginHandler)

  <span class="cm">// GET /api/auth/me â€” protegido, devuelve el usuario actual</span>
  fastify.get('/me', {
    preHandler: [requireAuth],
    schema: { tags: ['Auth'], summary: 'Obtener usuario actual' }
  }, getMeHandler)
}</pre>
      </div>

      <h3>// 5. middleware de verificaciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/middlewares/auth.middleware.js</span><span class="code-lang">js</span></div>
        <pre>export async function requireAuth(request, reply) {
  try {
    <span class="cm">// verifica el token del header Authorization: Bearer ...</span>
    <span class="cm">// si es vÃ¡lido, popula request.user con { id, email, role }</span>
    await request.jwtVerify()
  } catch {
    reply.code(401).send({ statusCode: 401, message: 'Token invÃ¡lido o expirado' })
  }
}</pre>
      </div>

      <h3>// 6. cÃ³mo usarlo desde el frontend</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ frontend â€” login y uso del token</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// 1. hacer login y guardar el token</span>
async function login(email, password) {
  const res = await fetch('http://localhost:3000/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password })
  })
  const { user, token } = await res.json()

  <span class="cm">// guardar en localStorage</span>
  localStorage.setItem('token', token)
  localStorage.setItem('user', JSON.stringify(user))
}

<span class="cm">// 2. funciÃ³n helper para peticiones autenticadas</span>
async function apiFetch(url, options = {}) {
  const token = localStorage.getItem('token')

  return fetch(`http://localhost:3000${url}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,  <span class="cm">// â† aquÃ­ viaja el token</span>
      ...options.headers
    }
  })
}

<span class="cm">// 3. usar en cualquier peticiÃ³n protegida</span>
const res = await apiFetch('/api/sales')
const data = await res.json()

<span class="cm">// 4. logout â€” simplemente borrar el token</span>
function logout() {
  localStorage.removeItem('token')
  localStorage.removeItem('user')
  window.location.href = '/login'
}</pre>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">localStorage vs cookies</div>
          <p><code>localStorage</code> es simple pero vulnerable a ataques XSS. En producciÃ³n considera usar cookies <code>httpOnly</code> que el navegador maneja automÃ¡ticamente y JavaScript no puede leer. Para este tutorial usamos localStorage por simplicidad.</p>
        </div>
      </div>

    </div>

    <!-- PASO 12B: AUTH.JS / BETTER AUTH -->
    <div class="section" id="paso-12b">
      <div class="section-header">
        <div class="step-number">12+</div>
        <div>
          <div class="section-title">Auth.js y Better Auth con Fastify</div>
          <div class="section-desc">LibrerÃ­as de autenticaciÃ³n para el frontend separado del backend.</div>
        </div>
      </div>

      <p>Auth.js y Better Auth son librerÃ­as que manejan todo el flujo de autenticaciÃ³n por ti â€” sesiones, tokens, login con Google/GitHub, etc. A diferencia de Next.js donde todo vive junto, aquÃ­ el frontend y backend son aplicaciones separadas.</p>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">La diferencia con Next.js</div>
          <p>En Next.js con SSR, Auth.js vive en el servidor y lee las cookies directamente. En nuestra arquitectura, el frontend React/Vue estÃ¡ separado del backend Fastify, entonces Auth.js vive en el <strong>frontend</strong> y se comunica con Fastify via HTTP.</p>
        </div>
      </div>

      <h3>// opciÃ³n A â€” Better Auth (recomendado para APIs separadas)</h3>
      <p>Better Auth tiene soporte nativo para backends separados. Se instala en el frontend y apunta a tu API Fastify.</p>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal â€” en el proyecto frontend</span><span class="code-lang">bash</span></div>
        <pre>npm install better-auth</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ frontend/src/lib/auth.js</span><span class="code-lang">js</span></div>
        <pre>import { createAuthClient } from 'better-auth/client'

export const authClient = createAuthClient({
  <span class="cm">// apunta a tu backend Fastify</span>
  baseURL: 'http://localhost:3000/api/auth'
})

<span class="cm">// uso en cualquier componente:</span>
const { data, error } = await authClient.signIn.email({
  email: 'juan@mail.com',
  password: '12345'
})

<span class="cm">// el token se maneja automÃ¡ticamente</span>
<span class="cm">// Better Auth lo guarda y lo envÃ­a en cada peticiÃ³n</span></pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ frontend/src/lib/auth.js â€” con Google OAuth</span><span class="code-lang">js</span></div>
        <pre>import { createAuthClient } from 'better-auth/client'

export const authClient = createAuthClient({
  baseURL: 'http://localhost:3000/api/auth',
  plugins: []
})

<span class="cm">// login con Google</span>
await authClient.signIn.social({ provider: 'google' })

<span class="cm">// login con GitHub</span>
await authClient.signIn.social({ provider: 'github' })

<span class="cm">// obtener sesiÃ³n actual</span>
const session = await authClient.getSession()
console.log(session.user.role)</pre>
      </div>

      <h3>// opciÃ³n B â€” Auth.js (mejor para React/Vue standalone)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal â€” en el proyecto frontend</span><span class="code-lang">bash</span></div>
        <pre>npm install next-auth@beta
<span class="cm"># o para React sin Next.js:</span>
npm install @auth/react</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ frontend/src/lib/auth.js</span><span class="code-lang">js</span></div>
        <pre>import { Auth } from '@auth/core'
import Credentials from '@auth/core/providers/credentials'

export const authConfig = {
  providers: [
    Credentials({
      async authorize(credentials) {
        <span class="cm">// llama a tu backend Fastify para verificar credenciales</span>
        const res = await fetch('http://localhost:3000/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials)
        })

        if (!res.ok) return null

        const { user, token } = await res.json()
        <span class="cm">// devolver el usuario con el token de Fastify</span>
        return { ...user, accessToken: token }
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      <span class="cm">// guardar el token de Fastify en el JWT de Auth.js</span>
      if (user) token.accessToken = user.accessToken
      return token
    },
    async session({ session, token }) {
      <span class="cm">// exponer el token en la sesiÃ³n para usarlo en peticiones</span>
      session.accessToken = token.accessToken
      return session
    }
  }
}</pre>
      </div>

      <h3>// cÃ³mo usar el token de Fastify con Auth.js</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ frontend â€” peticiÃ³n autenticada con Auth.js</span><span class="code-lang">js</span></div>
        <pre>import { useSession } from '@auth/react'

function SalesPage() {
  const { data: session } = useSession()

  async function fetchSales() {
    <span class="cm">// usar el token de Fastify que guardamos en la sesiÃ³n</span>
    const res = await fetch('http://localhost:3000/api/sales', {
      headers: {
        'Authorization': `Bearer ${session.accessToken}`
      }
    })
    return res.json()
  }
}</pre>
      </div>

      <h3>// comparaciÃ³n: Â¿cuÃ¡l usar?</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ referencia rÃ¡pida</span><span class="code-lang">bash</span></div>
        <pre>                    JWT manual    Better Auth    Auth.js
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ConfiguraciÃ³n        Simple        Simple         Media
OAuth (Google etc.)  Manual        âœ… incluido    âœ… incluido
Control total        âœ…            Medio          Medio
Frontend separado    âœ…            âœ…             Requiere config
Recomendado para     APIs simples  Apps modernas  Ecosistema React</pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">âœ…</span>
        <div>
          <div class="callout-title">RecomendaciÃ³n</div>
          <p>Si solo necesitas email/password, el JWT manual de Fastify es suficiente y mÃ¡s simple. Si necesitas login con Google, GitHub u otros proveedores, usa <strong>Better Auth</strong> â€” tiene mejor soporte para backends separados que Auth.js.</p>
        </div>
      </div>

    </div>

    <!-- PASO 13: ROLES -->
    <div class="section" id="paso-13">
      <div class="section-header">
        <div class="step-number">13</div>
        <div>
          <div class="section-title">Roles y Permisos (RBAC)</div>
          <div class="section-desc">El rol define quiÃ©n eres. Los permisos definen quÃ© puedes hacer. Se verifican en la ruta, antes del controller.</div>
        </div>
      </div>

      <p>RBAC significa <strong>Role Based Access Control</strong> â€” control de acceso basado en roles. En lugar de definir permisos individuales por usuario, defines roles (ADMIN, USER) y cada rol tiene acceso a ciertos endpoints.</p>

      <div class="grid-2">
        <div class="card">
          <h4>ğŸ‘¤ Rol USER</h4>
          <p>Puede ver y crear sus propias ventas. No puede eliminar ventas ni ver las ventas de otros usuarios.</p>
        </div>
        <div class="card">
          <h4>ğŸ‘‘ Rol ADMIN</h4>
          <p>Puede ver todas las ventas, eliminar cualquier venta, gestionar productos y acceder a endpoints administrativos.</p>
        </div>
      </div>

      <h3>// 1. el rol vive en la base de datos</h3>
      <p>El rol se asigna cuando se crea el usuario. Por defecto es USER. Solo se puede cambiar a ADMIN directamente en la base de datos o con un endpoint administrativo.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prisma/schema.prisma</span><span class="code-lang">prisma</span></div>
        <pre>model User {
  id    String @id @default(uuid())
  email String @unique
  role  Role   @default(USER)   <span class="cm">// todos empiezan como USER</span>
}

enum Role {
  USER
  ADMIN
}</pre>
      </div>

      <h3>// 2. el rol viaja dentro del JWT</h3>
      <p>Cuando el usuario hace login, el rol se incluye dentro del token JWT. AsÃ­ no necesitamos consultar la base de datos en cada peticiÃ³n para saber quÃ© rol tiene.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/auth/auth.service.js (fragmento)</span><span class="code-lang">js</span></div>
        <pre>export async function loginUser({ email, password }, fastify) {
  const user = await prisma.user.findUnique({ where: { email } })
  <span class="cm">// ... validar contraseÃ±a ...</span>

  <span class="cm">// el rol se guarda DENTRO del token</span>
  const token = fastify.jwt.sign({
    id:    user.id,
    email: user.email,
    role:  user.role   <span class="cm">// â† aquÃ­ viaja el rol</span>
  })

  return { user, token }
}

<span class="cm">// el token decodificado contiene:</span>
<span class="cm">// { id: "abc-123", email: "juan@mail.com", role: "ADMIN", iat: ..., exp: ... }</span></pre>
      </div>

      <h3>// 3. cÃ³mo fluye el rol desde el frontend hasta la ruta</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ flujo completo</span><span class="code-lang">bash</span></div>
        <pre>1. Usuario hace login â†’ recibe el token JWT
   { token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." }

2. Frontend guarda el token (localStorage o cookie)

3. En cada peticiÃ³n el frontend envÃ­a el token en el header:
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

4. requireAuth verifica el token â†’ extrae el payload
   request.user = { id: "abc-123", email: "juan@mail.com", role: "ADMIN" }

5. requireRole('ADMIN') verifica request.user.role
   âœ… es ADMIN â†’ pasa al controller
   âŒ es USER  â†’ 403 Forbidden</pre>
      </div>

      <h3>// 4. el middleware â€” patrÃ³n factory</h3>
      <p>Es una funciÃ³n que devuelve otra funciÃ³n. Esto permite pasarle el rol requerido como argumento.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/middlewares/roles.middleware.js</span><span class="code-lang">js</span></div>
        <pre>export function requireRole(...roles) {
  <span class="cm">// devuelve un middleware que Fastify puede ejecutar en preHandler</span>
  return async function (request, reply) {
    if (!roles.includes(request.user.role)) {
      return reply.code(403).send({
        statusCode: 403,
        error: 'Forbidden',
        message: `Acceso denegado. Se requiere rol: ${roles.join(' o ')}`
      })
    }
    <span class="cm">// si tiene el rol correcto, no hace nada y la peticiÃ³n continÃºa</span>
  }
}</pre>
      </div>

      <h3>// 5. dÃ³nde se llama â€” en cada ruta del mÃ³dulo</h3>
      <p>Se aplica en el <code>preHandler</code> de cada ruta que necesita protecciÃ³n. Siempre despuÃ©s de <code>requireAuth</code> porque primero necesitamos saber quiÃ©n es el usuario para luego verificar su rol.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.routes.js</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { requireRole } from '../../shared/middlewares/roles.middleware.js'

export async function salesRoutes(fastify) {

  <span class="cm">// cualquier usuario autenticado puede listar ventas</span>
  fastify.get('/', {
    preHandler: [requireAuth]
  }, listSalesHandler)

  <span class="cm">// cualquier usuario autenticado puede crear una venta</span>
  fastify.post('/', {
    preHandler: [requireAuth]
  }, createSaleHandler)

  <span class="cm">// solo ADMIN puede eliminar ventas</span>
  fastify.delete('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN')]
  }, deleteSaleHandler)

  <span class="cm">// solo ADMIN puede ver el reporte general</span>
  fastify.get('/report', {
    preHandler: [requireAuth, requireRole('ADMIN')]
  }, getSalesReportHandler)
}</pre>
      </div>

      <h3>// 6. quÃ© recibe el frontend segÃºn el rol</h3>
      <div class="compare">
        <div class="compare-box good">
          <div class="compare-header">âœ… ADMIN hace DELETE /api/sales/123</div>
          <pre>// Authorization: Bearer token-de-admin
// request.user.role = "ADMIN"
// requireRole('ADMIN') â†’ pasa
// controller ejecuta â†’ 204 No Content</pre>
        </div>
        <div class="compare-box bad">
          <div class="compare-header">âŒ USER hace DELETE /api/sales/123</div>
          <pre>// Authorization: Bearer token-de-user
// request.user.role = "USER"
// requireRole('ADMIN') â†’ bloquea
// nunca llega al controller â†’ 403 Forbidden</pre>
        </div>
      </div>

      <h3>// 7. cÃ³mo manejar roles desde el frontend</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ ejemplo en el frontend (cualquier framework)</span><span class="code-lang">js</span></div>
        <pre"><span class="cm">// 1. al hacer login, guardar el token y el rol</span>
const { user, token } = await login({ email, password })
localStorage.setItem('token', token)
localStorage.setItem('role', user.role)

<span class="cm">// 2. en cada peticiÃ³n, enviar el token en el header</span>
const response = await fetch('/api/sales', {
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
})

<span class="cm">// 3. mostrar/ocultar elementos segÃºn el rol</span>
const role = localStorage.getItem('role')
if (role === 'ADMIN') {
  mostrarBotonEliminar()
}

<span class="cm">// IMPORTANTE: ocultar en el frontend es solo UX</span>
<span class="cm">// La verdadera protecciÃ³n siempre estÃ¡ en el backend con requireRole</span></pre>
      </div>

      <div class="callout danger">
        <span class="callout-icon">ğŸš¨</span>
        <div>
          <div class="callout-title">Nunca confÃ­es solo en el frontend para los permisos</div>
          <p>Ocultar un botÃ³n en el frontend es solo experiencia de usuario. Cualquier persona puede hacer una peticiÃ³n directamente desde Postman o curl sin importar lo que muestre el frontend. La verificaciÃ³n de roles <strong>siempre debe estar en el backend</strong> con <code>requireRole</code>.</p>
        </div>
      </div>

    </div>

    <!-- PASO 14: CORS -->
    <div class="section" id="paso-14">
      <div class="section-header">
        <div class="step-number">14</div>
        <div>
          <div class="section-title">CORS</div>
          <div class="section-desc">Cross-Origin Resource Sharing â€” controla quÃ© dominios pueden consumir tu API.</div>
        </div>
      </div>

      <p>CORS es un mecanismo del navegador que bloquea peticiones que vienen de un dominio diferente al de la API. Si tu frontend estÃ¡ en <code>tuapp.com</code> y tu API estÃ¡ en <code>api.tuapp.com</code>, el navegador bloquea esa peticiÃ³n por defecto. CORS le dice al navegador quÃ© orÃ­genes estÃ¡n permitidos.</p>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">CORS solo lo valida el navegador</div>
          <p>Herramientas como Postman, curl o aplicaciones mÃ³viles no envÃ­an el header <code>Origin</code>, por eso no son bloqueadas por CORS. Solo los navegadores web aplican esta restricciÃ³n.</p>
        </div>
      </div>

      <h3>// 1. instalaciÃ³n (ya incluida en el proyecto)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npm install @fastify/cors</pre>
      </div>

      <h3>// 2. el plugin â€” configuraciÃ³n central</h3>
      <p>Se configura en un solo lugar y aplica a todos los mÃ³dulos automÃ¡ticamente. Los orÃ­genes permitidos cambian segÃºn el entorno.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/plugins/cors.plugin.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import fastifyCors from '@fastify/cors'
import { env } from '../../config/env.js'

<span class="cm">// orÃ­genes permitidos segÃºn el entorno</span>
<span class="cm">// en desarrollo: localhost del frontend</span>
<span class="cm">// en producciÃ³n: solo tus dominios reales</span>
const origins = {
  development: ['http://localhost:3000', 'http://localhost:5173'],
  production:  ['https://tuapp.com', 'https://app.tuapp.com']
}

export const corsPlugin = fp(async (fastify) => {
  fastify.register(fastifyCors, {

    <span class="cm">// origin: funciÃ³n que decide si el origen estÃ¡ permitido</span>
    origin: (origin, callback) => {
      const allowed = origins[env.NODE_ENV] || []

      <span class="cm">// sin origin â†’ Postman, curl, apps mÃ³viles â†’ siempre permitir</span>
      <span class="cm">// con origin â†’ verificar si estÃ¡ en la lista</span>
      if (!origin || allowed.includes(origin)) {
        callback(null, true)   <span class="cm">// âœ… permitido</span>
      } else {
        callback(new Error('Origen no permitido'), false)  <span class="cm">// âŒ bloqueado</span>
      }
    },

    <span class="cm">// methods: quÃ© mÃ©todos HTTP estÃ¡n permitidos desde el navegador</span>
    methods: ['GET', 'POST', 'PATCH', 'DELETE'],

    <span class="cm">// credentials: permite enviar cookies y headers de autorizaciÃ³n</span>
    <span class="cm">// necesario si usas JWT en el header Authorization</span>
    credentials: true
  })
})</pre>
      </div>

      <h3>// 3. dÃ³nde se llama â€” en app.js</h3>
      <p>El plugin se registra una sola vez en <code>app.js</code> y Fastify lo aplica automÃ¡ticamente a todas las rutas de todos los mÃ³dulos.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>import { corsPlugin } from './shared/plugins/cors.plugin.js'

export function buildApp() {
  const app = Fastify({ ... })

  <span class="cm">// registrar CORS antes que los mÃ³dulos</span>
  <span class="cm">// asÃ­ aplica a todas las rutas de sales, auth, products, etc.</span>
  app.register(corsPlugin)

  app.register(authModule,  { prefix: '/api/auth' })
  app.register(salesModule, { prefix: '/api/sales' })

  return app
}</pre>
      </div>

      <h3>// 4. quÃ© pasa cuando un origen no estÃ¡ permitido</h3>
      <div class="compare">
        <div class="compare-box good">
          <div class="compare-header">âœ… Origen permitido</div>
          <pre>// peticiÃ³n desde http://localhost:5173
// estÃ¡ en la lista de development

GET /api/sales
Origin: http://localhost:5173

// respuesta normal con header:
Access-Control-Allow-Origin: http://localhost:5173</pre>
        </div>
        <div class="compare-box bad">
          <div class="compare-header">âŒ Origen bloqueado</div>
          <pre>// peticiÃ³n desde http://sitio-malicioso.com
// NO estÃ¡ en la lista

GET /api/sales
Origin: http://sitio-malicioso.com

// el navegador recibe error CORS
// la peticiÃ³n nunca llega al controller</pre>
        </div>
      </div>

      <h3>// 5. cÃ³mo agregar nuevos orÃ­genes permitidos</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/plugins/cors.plugin.js â€” agregar orÃ­genes</span><span class="code-lang">js</span></div>
        <pre>const origins = {
  development: [
    'http://localhost:3000',   <span class="cm">// frontend React/Vue</span>
    'http://localhost:5173',   <span class="cm">// Vite dev server</span>
    'http://localhost:4200',   <span class="cm">// Angular dev server</span>
  ],
  production: [
    'https://tuapp.com',
    'https://app.tuapp.com',
    'https://admin.tuapp.com'  <span class="cm">// panel administrativo</span>
  ]
}</pre>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">Nunca uses origin: '*' en producciÃ³n</div>
          <p>El wildcard <code>*</code> permite que cualquier dominio consuma tu API. En desarrollo puede ser Ãºtil, pero en producciÃ³n siempre especifica los dominios exactos que deben tener acceso.</p>
        </div>
      </div>

    </div>

    <!-- PASO 15: RATE LIMITING -->
    <div class="section" id="paso-15">
      <div class="section-header">
        <div class="step-number">15</div>
        <div>
          <div class="section-title">Rate Limiting</div>
          <div class="section-desc">Limita cuÃ¡ntas peticiones puede hacer una IP en un perÃ­odo de tiempo. Previene ataques DDoS y abuso de endpoints.</div>
        </div>
      </div>

      <p>Sin rate limiting, cualquier persona podrÃ­a hacer miles de peticiones por segundo contra tu API â€” ya sea para tumbar el servidor, intentar adivinar contraseÃ±as, o abusar de endpoints costosos. El rate limiting bloquea la IP automÃ¡ticamente cuando supera el lÃ­mite configurado.</p>

      <p>No todos los endpoints necesitan el mismo lÃ­mite. Un endpoint de consulta puede recibir mÃ¡s trÃ¡fico que uno de login o de subida de archivos.</p>

      <h3>// 1. instalaciÃ³n (ya incluida en el proyecto)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npm install @fastify/rate-limit</pre>
      </div>

      <h3>// 2. configuraciÃ³n global en app.js</h3>
      <p>El rate limiting global aplica a <strong>todos</strong> los endpoints de la app. Es la primera lÃ­nea de defensa.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>import rateLimit from '@fastify/rate-limit'

app.register(rateLimit, {
  max: 100,                   <span class="cm">// mÃ¡ximo 100 peticiones</span>
  timeWindow: '1 minute',     <span class="cm">// por IP, por minuto</span>
  errorResponseBuilder: () => ({
    statusCode: 429,
    error: 'Too Many Requests',
    message: 'Demasiadas peticiones. Intenta en 1 minuto.'
  })
})

<span class="cm">// a partir de aquÃ­, si una IP supera 100 req/min</span>
<span class="cm">// Fastify devuelve automÃ¡ticamente un 429 sin llegar al controller</span></pre>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">Â¿DÃ³nde vive el rate limiting?</div>
          <p>El rate limiting es un plugin de infraestructura â€” vive en <code>app.js</code> para la configuraciÃ³n global, y en <code>routes.js</code> de cada mÃ³dulo para lÃ­mites especÃ­ficos por ruta. <strong>No va en el service ni en el repository</strong> porque no es lÃ³gica de negocio, es infraestructura.</p>
        </div>
      </div>

      <h3>// 3. lÃ­mites diferenciados por ruta â€” en routes.js</h3>
      <p>Algunos endpoints necesitan mÃ¡s protecciÃ³n que otros. Esto se configura directamente en la definiciÃ³n de la ruta.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/auth/auth.routes.js</span><span class="code-lang">js</span></div>
        <pre>export async function authRoutes(fastify) {

  <span class="cm">// login â€” muy estricto: solo 5 intentos cada 15 minutos por IP</span>
  <span class="cm">// evita ataques de fuerza bruta para adivinar contraseÃ±as</span>
  fastify.post('/login', {
    config: {
      rateLimit: {
        max: 5,
        timeWindow: '15 minutes',
        errorResponseBuilder: () => ({
          statusCode: 429,
          error: 'Too Many Requests',
          message: 'Demasiados intentos de login. Espera 15 minutos.'
        })
      }
    }
  }, loginHandler)

  <span class="cm">// registro â€” moderado: 10 cuentas por hora por IP</span>
  fastify.post('/register', {
    config: {
      rateLimit: { max: 10, timeWindow: '1 hour' }
    }
  }, registerHandler)
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.routes.js (fragmento)</span><span class="code-lang">js</span></div>
        <pre">export async function salesRoutes(fastify) {

  <span class="cm">// listar ventas â€” usa el lÃ­mite global (100/min)</span>
  <span class="cm">// es una consulta simple, no necesita lÃ­mite extra</span>
  fastify.get('/', { preHandler: [requireAuth] }, listSalesHandler)

  <span class="cm">// crear venta â€” moderado: 30 ventas por minuto por IP</span>
  fastify.post('/', {
    preHandler: [requireAuth],
    config: {
      rateLimit: { max: 30, timeWindow: '1 minute' }
    }
  }, createSaleHandler)

  <span class="cm">// subida de archivos â€” muy estricto: consume muchos recursos</span>
  fastify.post('/upload', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    config: {
      rateLimit: {
        max: 10,
        timeWindow: '1 hour',
        errorResponseBuilder: () => ({
          statusCode: 429,
          message: 'LÃ­mite de subida alcanzado. Espera 1 hora.'
        })
      }
    }
  }, uploadHandler)
}</pre>
      </div>

      <h3>// 4. cÃ³mo se ve cuando una IP es bloqueada</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ respuesta HTTP 429</span><span class="code-lang">json</span></div>
        <pre>{
  "statusCode": 429,
  "error": "Too Many Requests",
  "message": "Demasiados intentos de login. Espera 15 minutos."
}</pre>
      </div>

      <h3>// 5. tabla de referencia â€” lÃ­mites recomendados</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ referencia rÃ¡pida</span><span class="code-lang">bash</span></div>
        <pre>Endpoint              LÃ­mite sugerido       RazÃ³n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GET  /products        100 req/min (global)  consulta simple
GET  /sales           100 req/min (global)  consulta simple
POST /sales           30  req/min           operaciÃ³n de escritura
POST /auth/login      5   cada 15 min       prevenir fuerza bruta
POST /auth/register   10  cada 1 hora       prevenir spam de cuentas
POST /upload          10  cada 1 hora       consume muchos recursos</pre>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">El rate limiting por ruta sobreescribe el global</div>
          <p>Si el lÃ­mite global es 100/min pero el login tiene 5 cada 15 minutos, el login usarÃ¡ su propio lÃ­mite. El lÃ­mite mÃ¡s especÃ­fico siempre gana.</p>
        </div>
      </div>

    </div>

    <!-- PASO 16: SQL INJECTION -->
    <div class="section" id="paso-16">
      <div class="section-header">
        <div class="step-number">16</div>
        <div>
          <div class="section-title">PrevenciÃ³n SQL Injection</div>
          <div class="section-desc">Prisma protege por defecto. SanitizaciÃ³n extra para query params.</div>
        </div>
      </div>

      <div class="callout success">
        <span class="callout-icon">ğŸ›¡ï¸</span>
        <div>
          <div class="callout-title">Prisma usa queries parametrizadas internamente</div>
          <p>Si usas la API normal de Prisma, estÃ¡s protegido automÃ¡ticamente. El peligro solo existe si usas <code>$queryRawUnsafe</code>. Nunca lo uses con datos del usuario.</p>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/utils/sanitize.js</span><span class="code-lang">js</span></div>
        <pre>export function sanitizeQuery(query) {
  const result = {}
  for (const [key, value] of Object.entries(query)) {
    if (typeof value === 'string') {
      result[key] = value
        .replace(/[<>'"`;\\]/g, '')  <span class="cm">// eliminar caracteres peligrosos</span>
        .trim()
        .slice(0, 200)               <span class="cm">// limitar longitud mÃ¡xima</span>
    } else {
      result[key] = value
    }
  }
  return result
}

<span class="cm">// Si NECESITAS usar queryRaw, usa siempre el tagged template (seguro)</span>
import { Prisma } from '@prisma/client'

export async function searchSalesRaw(status) {
  <span class="cm">// âœ… seguro â€” parametrizado</span>
  return prisma.$queryRaw`SELECT * FROM sales WHERE status = ${status}`

  <span class="cm">// âŒ NUNCA asÃ­ â€” vulnerable a SQL injection</span>
  <span class="cm">// return prisma.$queryRawUnsafe(`SELECT * WHERE status = '${status}'`)</span>
}</pre>
      </div>
    </div>

    <!-- PASO 17: REDIS -->
    <div class="section" id="paso-17">
      <div class="section-header">
        <div class="step-number">17</div>
        <div>
          <div class="section-title">Redis Cache</div>
          <div class="section-desc">Base de datos en memoria para cachear resultados y evitar consultas repetidas a PostgreSQL.</div>
        </div>
      </div>

      <p>Redis es una base de datos NoSQL que vive en memoria RAM. Es extremadamente rÃ¡pido porque no necesita ir al disco. Lo usamos para guardar temporalmente resultados de consultas costosas para que la prÃ³xima vez que alguien pida el mismo dato, lo entregamos desde Redis sin tocar PostgreSQL.</p>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">Â¿En quÃ© capa vive Redis?</div>
          <p>En el <strong>service</strong>. Decidir si un dato viene del cachÃ© o de la base de datos es una decisiÃ³n de negocio â€” no es responsabilidad del controller ni del repository. El flujo es: primero busca en Redis, si no estÃ¡ va al repository, guarda en Redis y devuelve.</p>
        </div>
      </div>

      <h3>// 1. instalaciÃ³n de Redis en tu mÃ¡quina</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal â€” Mac</span><span class="code-lang">bash</span></div>
        <pre>brew install redis
brew services start redis</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal â€” Ubuntu/Debian</span><span class="code-lang">bash</span></div>
        <pre>sudo apt install redis-server
sudo systemctl start redis</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal â€” verificar que funciona</span><span class="code-lang">bash</span></div>
        <pre>redis-cli ping
<span class="cm"># debe responder: PONG</span></pre>
      </div>

      <h3>// 2. variable de entorno (ya configurada en .env)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ .env</span><span class="code-lang">env</span></div>
        <pre>REDIS_URL=redis://localhost:6379</pre>
      </div>

      <h3>// 3. plugin â€” conexiÃ³n compartida en toda la app</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/plugins/redis.plugin.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import Redis from 'ioredis'
import { env } from '../../config/env.js'

<span class="cm">// instancia Ãºnica â€” la misma conexiÃ³n para toda la app</span>
export const redis = new Redis(env.REDIS_URL, {
  lazyConnect: true,
  retryStrategy: (times) => Math.min(times * 100, 3000)  <span class="cm">// reintenta si falla</span>
})

export const redisPlugin = fp(async (fastify) => {
  await redis.connect()
  fastify.log.info('âœ… Redis conectado')

  <span class="cm">// cerrar la conexiÃ³n cuando la app se apague</span>
  fastify.addHook('onClose', async () => {
    await redis.quit()
    fastify.log.info('Redis desconectado')
  })
})</pre>
      </div>

      <h3>// 4. cuÃ¡ndo usar cachÃ© y cuÃ¡ndo no</h3>
      <div class="compare">
        <div class="compare-box good">
          <div class="compare-header">âœ… Cachear esto</div>
          <pre>// datos que se leen mucho y cambian poco
getSaleById(id)       // detalle de una venta
getProductById(id)    // detalle de un producto
getUserById(id)       // perfil de usuario
listCategories()      // catÃ¡logos estÃ¡ticos</pre>
        </div>
        <div class="compare-box bad">
          <div class="compare-header">âŒ No cachear esto</div>
          <pre>// datos que cambian constantemente
listSales()    // cambia con cada venta nueva
getStock()     // cambia con cada compra
login()        // siempre debe ir a la BD
createSale()   // operaciones de escritura</pre>
        </div>
      </div>

      <h3>// 5. implementaciÃ³n en el service â€” patrÃ³n cache-aside</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.service.js</span><span class="code-lang">js</span></div>
        <pre>import { redis } from '../../shared/plugins/redis.plugin.js'
import { findSaleById, updateSale } from './sales.repository.js'

export async function getSaleById(id) {
  const key = `sale:${id}`  <span class="cm">// clave Ãºnica por venta</span>

  <span class="cm">// paso 1: buscar en Redis primero</span>
  const cached = await redis.get(key)
  if (cached) {
    return JSON.parse(cached)  <span class="cm">// â† respuesta rÃ¡pida desde memoria</span>
  }

  <span class="cm">// paso 2: si no estÃ¡ en cachÃ©, ir a PostgreSQL</span>
  const sale = await findSaleById(id)
  if (!sale) {
    const err = new Error('Venta no encontrada')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// paso 3: guardar en Redis por 5 minutos (300 segundos)</span>
  <span class="cm">// 'EX' significa que expira automÃ¡ticamente</span>
  await redis.set(key, JSON.stringify(sale), 'EX', 300)

  return sale
}

export async function updateSaleStatus(id, data, requestUser) {
  <span class="cm">// ... validaciones de negocio ...</span>

  const sale = await updateSale(id, data)

  <span class="cm">// paso importante: invalidar el cachÃ© al actualizar</span>
  <span class="cm">// si no lo haces, el cachÃ© devolverÃ­a datos desactualizados</span>
  await redis.del(`sale:${id}`)

  return sale
}

export async function removeSale(id, requestUser) {
  <span class="cm">// ... validaciones ...</span>
  await deleteById(id)

  <span class="cm">// tambiÃ©n invalidar al eliminar</span>
  await redis.del(`sale:${id}`)
}</pre>
      </div>

      <h3>// 6. flujo visual completo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ GET /api/sales/:id â€” con cachÃ©</span><span class="code-lang">bash</span></div>
        <pre>Primera peticiÃ³n:
  controller â†’ service â†’ Redis âŒ no estÃ¡
                       â†’ repository â†’ PostgreSQL âœ…
                       â†’ guarda en Redis (5 min)
                       â†’ devuelve dato
  Tiempo: ~50ms

Segunda peticiÃ³n (dentro de 5 min):
  controller â†’ service â†’ Redis âœ… encontrado
                       â†’ devuelve dato
  Tiempo: ~2ms   â† 25x mÃ¡s rÃ¡pido</pre>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">Siempre invalida el cachÃ© al modificar datos</div>
          <p>Si actualizas o eliminas un registro en PostgreSQL pero no borras su clave en Redis, la prÃ³xima consulta devolverÃ¡ datos desactualizados. Usa <code>redis.del(key)</code> en cualquier operaciÃ³n de escritura.</p>
        </div>
      </div>

    </div>

    <!-- PASO 18: ERRORES -->
    <div class="section" id="paso-18">
      <div class="section-header">
        <div class="step-number">18</div>
        <div>
          <div class="section-title">Manejo Global de Errores</div>
          <div class="section-desc">Un Ãºnico lugar que captura todos los errores de todos los mÃ³dulos.</div>
        </div>
      </div>

      <p>Sin un manejador global, tendrÃ­as que poner un <code>try/catch</code> en cada controller de cada mÃ³dulo. Eso significa cÃ³digo repetido en ventas, Ã³rdenes, productos, usuarios... y si quieres cambiar el formato de los errores, tienes que tocarlo en todos lados.</p>

      <p>Con <code>app.setErrorHandler()</code> le dices a Fastify: <strong>cualquier error que no se capture en ningÃºn lado, mÃ¡ndaselo a esta funciÃ³n</strong>. Y Fastify lo hace automÃ¡ticamente.</p>

      <h3>// cÃ³mo se propaga un error por las capas</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ flujo de propagaciÃ³n</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// 1. el service lanza un error</span>
export async function getSaleById(id) {
  const sale = await findSaleById(id)
  if (!sale) {
    const err = new Error('Venta no encontrada')
    err.statusCode = 404
    throw err   <span class="cm">// â† se lanza aquÃ­</span>
  }
  return sale
}

<span class="cm">// 2. el controller NO tiene try/catch â€” no lo captura</span>
export async function getSaleHandler(request, reply) {
  const sale = await getSaleById(request.params.id)  <span class="cm">// el error sube hasta aquÃ­</span>
  return reply.send(sale)                             <span class="cm">// y sigue subiendo...</span>
}

<span class="cm">// 3. Fastify lo intercepta automÃ¡ticamente</span>
<span class="cm">// 4. lo manda al errorHandler registrado en app.js</span>
<span class="cm">// 5. errorHandler decide quÃ© respuesta HTTP devolver</span></pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">âœ…</span>
        <div>
          <div class="callout-title">El resultado: controllers limpios</div>
          <p>Gracias al manejador global, los controllers no necesitan <code>try/catch</code>. Solo llaman al service y devuelven la respuesta. Si algo falla, Fastify lo redirige al errorHandler automÃ¡ticamente.</p>
        </div>
      </div>

      <h3>// registro en app.js â€” una sola lÃ­nea</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>app.setErrorHandler(errorHandler)
<span class="cm">// a partir de aquÃ­, cualquier error no capturado de cualquier mÃ³dulo</span>
<span class="cm">// (sales, auth, products, orders...) llega a esta funciÃ³n</span></pre>
      </div>

      <h3>// el manejador â€” quÃ© tipos de errores maneja</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/errors/error-handler.js</span><span class="code-lang">js</span></div>
        <pre>import { ZodError } from 'zod'

export async function errorHandler(error, request, reply) {
  request.log.error({ err: error, url: request.url }, 'Error capturado')

  <span class="cm">// tipo 1: errores de validaciÃ³n Zod (datos invÃ¡lidos del cliente)</span>
  if (error instanceof ZodError) {
    return reply.code(400).send({
      statusCode: 400,
      error: 'Validation Error',
      message: 'Datos invÃ¡lidos',
      details: error.errors.map(e => ({
        field: e.path.join('.'),
        message: e.message
      }))
    })
  }

  <span class="cm">// tipo 2: errores de negocio â€” lanzados desde el service con statusCode</span>
  <span class="cm">// ejemplo: { statusCode: 404, message: 'Venta no encontrada' }</span>
  <span class="cm">// ejemplo: { statusCode: 409, message: 'Stock insuficiente' }</span>
  <span class="cm">// ejemplo: { statusCode: 403, message: 'Sin permisos' }</span>
  if (error.statusCode) {
    return reply.code(error.statusCode).send({
      statusCode: error.statusCode,
      error: httpErrorName(error.statusCode),
      message: error.message
    })
  }

  <span class="cm">// tipo 3: errores de Prisma â€” registro duplicado (email Ãºnico, etc.)</span>
  if (error.code === 'P2002') {
    return reply.code(409).send({
      statusCode: 409,
      error: 'Conflict',
      message: 'Ya existe un registro con esos datos'
    })
  }

  <span class="cm">// tipo 4: errores de Prisma â€” registro no encontrado en update/delete</span>
  if (error.code === 'P2025') {
    return reply.code(404).send({
      statusCode: 404,
      error: 'Not Found',
      message: 'Registro no encontrado'
    })
  }

  <span class="cm">// tipo 5: error inesperado â€” nunca exponer detalles internos en producciÃ³n</span>
  return reply.code(500).send({
    statusCode: 500,
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'production'
      ? 'Error interno del servidor'
      : error.message
  })
}

function httpErrorName(code) {
  const map = {
    400: 'Bad Request',
    401: 'Unauthorized',
    403: 'Forbidden',
    404: 'Not Found',
    409: 'Conflict'
  }
  return map[code] || 'Error'
}</pre>
      </div>

      <h3>// cÃ³mo lanzar errores desde el service</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ patrÃ³n para lanzar errores de negocio</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// en cualquier service de cualquier mÃ³dulo â€” siempre el mismo patrÃ³n</span>
const err = new Error('mensaje descriptivo para el cliente')
err.statusCode = 404   <span class="cm">// 400, 401, 403, 404, 409...</span>
throw err

<span class="cm">// el errorHandler lo recibe y devuelve automÃ¡ticamente:</span>
<span class="cm">// { statusCode: 404, error: "Not Found", message: "mensaje descriptivo" }</span></pre>
      </div>

    </div>

    <!-- PASO 19: LOGS -->
    <div class="section" id="paso-19">
      <div class="section-header">
        <div class="step-number">19</div>
        <div>
          <div class="section-title">Logs Estructurados con Pino</div>
          <div class="section-desc">Fastify incluye Pino por defecto. Los logs mÃ¡s Ãºtiles van en el controller porque ahÃ­ estÃ¡ el contexto del usuario y la acciÃ³n.</div>
        </div>
      </div>

      <p>Pino ya estÃ¡ configurado en <code>app.js</code> cuando creamos Fastify con la opciÃ³n <code>logger</code>. No necesitas instalar nada extra ni configurar nada mÃ¡s â€” Fastify lo activa automÃ¡ticamente.</p>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">Â¿DÃ³nde van los logs en cada capa?</div>
          <p><strong>Controller</strong> â†’ quiÃ©n hizo quÃ© y con quÃ© datos. Es la capa mÃ¡s Ãºtil para loggear porque conoce al usuario y la acciÃ³n HTTP.<br>
          <strong>Service</strong> â†’ quÃ© regla de negocio se ejecutÃ³ o por quÃ© fallÃ³.<br>
          <strong>Repository</strong> â†’ solo en casos de debug muy especÃ­fico. Normalmente no se loggea aquÃ­.</p>
        </div>
      </div>

      <h3>// 1. configuraciÃ³n en app.js (ya incluida)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js</span><span class="code-lang">js</span></div>
        <pre>const app = Fastify({
  logger: {
    level: env.NODE_ENV === 'production' ? 'info' : 'debug',
    transport: env.NODE_ENV !== 'production'
      ? { target: 'pino-pretty', options: { colorize: true } }  <span class="cm">// dev: colores legibles</span>
      : undefined  <span class="cm">// prod: JSON puro para herramientas externas</span>
  }
})</pre>
      </div>

      <h3>// 2. niveles de log â€” cuÃ¡ndo usar cada uno</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ niveles disponibles</span><span class="code-lang">js</span></div>
        <pre>request.log.debug('detalle interno â€” solo en desarrollo')
request.log.info('operaciÃ³n normal â€” registro de actividad')
request.log.warn('algo sospechoso pero no crÃ­tico')
request.log.error({ err: error }, 'algo fallÃ³')</pre>
      </div>

      <h3>// 3. logs en el controller â€” el lugar mÃ¡s importante</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.controller.js</span><span class="code-lang">js</span></div>
        <pre>export async function createSaleHandler(request, reply) {
  <span class="cm">// log de entrada â€” quiÃ©n hizo quÃ©</span>
  request.log.info(
    { userId: request.user.id, items: request.body.items.length },
    'Creando venta'
  )

  const body = createSaleSchema.parse(request.body)
  const sale = await createSale({ userId: request.user.id, items: body.items })

  <span class="cm">// log de Ã©xito â€” quÃ© resultado se obtuvo</span>
  request.log.info(
    { userId: request.user.id, saleId: sale.id, total: sale.total },
    'Venta creada exitosamente'
  )

  return reply.code(201).send(sale)
}

export async function deleteSaleHandler(request, reply) {
  request.log.warn(
    { adminId: request.user.id, saleId: request.params.id },
    'Eliminando venta â€” acciÃ³n administrativa'
  )

  await removeSale(request.params.id, request.user)

  request.log.info(
    { adminId: request.user.id, saleId: request.params.id },
    'Venta eliminada'
  )

  return reply.code(204).send()
}

export async function listSalesHandler(request, reply) {
  const query = getSalesQuerySchema.parse(sanitizeQuery(request.query))
  if (request.user.role !== 'ADMIN') query.userId = request.user.id

  const result = await getAllSales(query)

  request.log.info(
    { userId: request.user.id, total: result.pagination.total, page: query.page },
    'Ventas listadas'
  )

  return reply.send(result)
}</pre>
      </div>

      <h3>// 4. logs en el service â€” reglas de negocio</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.service.js (fragmento)</span><span class="code-lang">js</span></div>
        <pre"><span class="cm">// el service no tiene acceso a request.log</span>
<span class="cm">// usa console o recibe el logger como parÃ¡metro</span>
import { buildApp } from '../../app.js'

export async function createSale({ userId, items }, log) {
  return prisma.$transaction(async (tx) => {
    for (const item of items) {
      const product = await tx.product.findUnique({ where: { id: item.productId } })

      if (product.stock < item.quantity) {
        <span class="cm">// log de advertencia de negocio</span>
        log.warn(
          { productId: item.productId, stock: product.stock, requested: item.quantity },
          'Intento de compra con stock insuficiente'
        )
        const err = new Error(`Stock insuficiente para "${product.name}"`)
        err.statusCode = 409
        throw err
      }
    }
    <span class="cm">// ... resto de la transacciÃ³n</span>
  })
}

<span class="cm">// en el controller se pasa el logger al service:</span>
const sale = await createSale({ userId: request.user.id, items: body.items }, request.log)</pre>
      </div>

      <h3>// 5. cÃ³mo se ve el output</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ desarrollo â€” pino-pretty (colores)</span><span class="code-lang">bash</span></div>
        <pre>[12:34:56.123] INFO (req-1): Creando venta
    userId: "abc-123"
    items: 3

[12:34:56.287] INFO (req-1): Venta creada exitosamente
    userId: "abc-123"
    saleId: "xyz-789"
    total: 150.00</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ producciÃ³n â€” JSON puro (para Datadog, CloudWatch, etc.)</span><span class="code-lang">json</span></div>
        <pre>{"level":30,"time":1704067200123,"reqId":"req-1","msg":"Creando venta","userId":"abc-123","items":3}
{"level":30,"time":1704067200287,"reqId":"req-1","msg":"Venta creada exitosamente","userId":"abc-123","saleId":"xyz-789","total":150}</pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">âœ…</span>
        <div>
          <div class="callout-title">reqId â€” trazabilidad automÃ¡tica</div>
          <p>Fastify genera automÃ¡ticamente un <code>reqId</code> Ãºnico por cada peticiÃ³n. Esto te permite buscar en los logs todo lo que ocurriÃ³ durante una peticiÃ³n especÃ­fica, incluso si hay miles de logs mezclados.</p>
        </div>
      </div>
    </div>

    <!-- PASO 20: PAGINACIÃ“N -->
    <div class="section" id="paso-20">
      <div class="section-header">
        <div class="step-number">20</div>
        <div>
          <div class="section-title">PaginaciÃ³n</div>
          <div class="section-desc">La paginaciÃ³n vive en el repository porque es una operaciÃ³n directa contra la base de datos.</div>
        </div>
      </div>

      <p>Paginar significa limitar los resultados a una cantidad determinada para evitar traer todos los datos de una sola vez. Imagina que tienes 50 ventas y quieres mostrar 10 por pÃ¡gina:</p>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ La fÃ³rmula clave</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// take  â†’ cuÃ¡ntos registros traer</span>
<span class="cm">// skip  â†’ cuÃ¡ntos saltarse antes de empezar</span>

<span class="cm">// PÃ¡gina 1: skip = (1-1) * 10 = 0  â†’ trae del 1 al 10</span>
<span class="cm">// PÃ¡gina 2: skip = (2-1) * 10 = 10 â†’ trae del 11 al 20</span>
<span class="cm">// PÃ¡gina 3: skip = (3-1) * 10 = 20 â†’ trae del 21 al 30</span>

const skip = (page - 1) * limit</pre>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">Â¿Por quÃ© Promise.all?</div>
          <p>Para mostrar el total de pÃ¡ginas necesitamos dos consultas: los datos paginados y el total de registros. Con <code>Promise.all</code> ambas corren en paralelo, reduciendo el tiempo de respuesta casi a la mitad.</p>
        </div>
      </div>

      <h3>// 1. repository â€” donde vive la paginaciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.repository.js</span><span class="code-lang">js</span></div>
        <pre>export async function findAllSales({ page = 1, limit = 10, status, userId } = {}) {
  const skip = (page - 1) * limit  <span class="cm">// cuÃ¡ntos registros saltarse</span>
  const where = {}
  if (status) where.status = status
  if (userId) where.userId = userId

  <span class="cm">// las dos consultas corren en paralelo</span>
  const [data, total] = await Promise.all([
    prisma.sale.findMany({
      where,
      take: limit,   <span class="cm">// cuÃ¡ntos traer</span>
      skip,          <span class="cm">// cuÃ¡ntos saltarse</span>
      include: {
        user:  { select: { id: true, name: true, email: true } },
        items: { include: { product: { select: { id: true, name: true } } } }
      },
      orderBy: { createdAt: 'desc' }
    }),
    prisma.sale.count({ where })  <span class="cm">// total de registros que coinciden</span>
  ])

  return { data, total }
}</pre>
      </div>

      <h3>// 2. service â€” consume el repository y construye la respuesta</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.service.js (fragmento)</span><span class="code-lang">js</span></div>
        <pre>import { findAllSales } from './sales.repository.js'
import { buildPagination } from '../../shared/utils/pagination.js'

export async function getAllSales({ page, limit, status, userId }) {
  const { data, total } = await findAllSales({ page, limit, status, userId })
  return buildPagination(data, total, page, limit)
}</pre>
      </div>

      <h3>// 3. utils â€” helper reutilizable en todos los mÃ³dulos</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/utils/pagination.js</span><span class="code-lang">js</span></div>
        <pre>export function buildPagination(data, total, page, limit) {
  const totalPages = Math.ceil(total / limit)  <span class="cm">// 50 ventas / 10 por pÃ¡gina = 5 pÃ¡ginas</span>
  return {
    data,
    pagination: {
      total,
      page:        Number(page),
      limit:       Number(limit),
      totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1
    }
  }
}</pre>
      </div>

      <h3>// 4. cÃ³mo se consume desde el cliente</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ peticiÃ³n HTTP</span><span class="code-lang">bash</span></div>
        <pre>GET /api/sales?page=2&limit=10
GET /api/sales?page=1&limit=10&status=PENDING</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ respuesta</span><span class="code-lang">json</span></div>
        <pre>{
  "data": [ ...10 ventas... ],
  "pagination": {
    "total": 50,
    "page": 2,
    "limit": 10,
    "totalPages": 5,
    "hasNextPage": true,
    "hasPrevPage": true
  }
}</pre>
      </div>
    </div>

    <!-- PASO 21: SWAGGER -->
    <div class="section" id="paso-21">
      <div class="section-header">
        <div class="step-number">21</div>
        <div>
          <div class="section-title">Swagger UI</div>
          <div class="section-desc">DocumentaciÃ³n interactiva autogenerada en /docs.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/plugins/swagger.plugin.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import fastifySwagger from '@fastify/swagger'
import fastifySwaggerUi from '@fastify/swagger-ui'

export const swaggerPlugin = fp(async (fastify) => {
  fastify.register(fastifySwagger, {
    openapi: {
      info: { title: 'Ventas API', version: '1.0.0' },
      components: {
        securitySchemes: {
          bearerAuth: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' }
        }
      }
    }
  })

  fastify.register(fastifySwaggerUi, {
    routePrefix: '/docs',
    uiConfig: { docExpansion: 'list' }
  })
})</pre>
      </div>

      <div class="callout success">
        <span class="callout-icon">ğŸ“š</span>
        <div>
          <div class="callout-title">La documentaciÃ³n se genera sola</div>
          <p>Los <code>schema: { tags, summary }</code> que defines en cada ruta aparecen automÃ¡ticamente en <code>http://localhost:3000/docs</code>.</p>
        </div>
      </div>
    </div>

    <!-- PASO 24: MÃ“DULO TRABAJADORES -->
    <div class="section" id="paso-24">
      <div class="section-header">
        <div class="step-number">24</div>
        <div>
          <div class="section-title">MÃ³dulo Trabajadores</div>
          <div class="section-desc">GestiÃ³n completa de personal: contrataciÃ³n, renuncia, reingreso, cambio de cargo y acceso al sistema.</div>
        </div>
      </div>

      <p>El mÃ³dulo de trabajadores maneja el ciclo de vida completo del personal. Nunca se elimina un registro â€” todo cambio queda registrado en el historial de movimientos para mantener trazabilidad.</p>

      <h3>// estructura del mÃ³dulo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“ src/modules/workers/</span><span class="code-lang">bash</span></div>
        <pre>workers/
â”œâ”€â”€ workers.module.js
â”œâ”€â”€ workers.routes.js
â”œâ”€â”€ workers.controller.js
â”œâ”€â”€ workers.service.js
â”œâ”€â”€ workers.repository.js
â””â”€â”€ workers.schema.js</pre>
      </div>

      <h3>// repository â€” consultas a la BD</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.repository.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'

export async function findAllWorkers({ page = 1, limit = 10, status, department } = {}) {
  const skip = (page - 1) * limit
  const where = {}
  if (status)     where.status = status
  if (department) where.department = department

  const [data, total] = await Promise.all([
    prisma.worker.findMany({
      where,
      skip,
      take: limit,
      include: {
        user: { select: { id: true, email: true, role: true, isActive: true } },
        movements: {
          orderBy: { createdAt: 'desc' },
          take: 1   <span class="cm">// solo el Ãºltimo movimiento en el listado</span>
        }
      },
      orderBy: { lastName: 'asc' }
    }),
    prisma.worker.count({ where })
  ])

  return { data, total }
}

export async function findWorkerById(id) {
  return prisma.worker.findUnique({
    where: { id },
    include: {
      user: { select: { id: true, email: true, role: true, isActive: true } },
      movements: { orderBy: { createdAt: 'desc' } }  <span class="cm">// historial completo</span>
    }
  })
}

export async function findWorkerByDni(dni) {
  return prisma.worker.findUnique({ where: { dni } })
}

export async function createWorker(data) {
  return prisma.worker.create({
    data,
    include: { movements: true }
  })
}

export async function updateWorker(id, data) {
  return prisma.worker.update({
    where: { id },
    data,
    include: { user: { select: { id: true, email: true, role: true } } }
  })
}

export async function createMovement(data) {
  return prisma.workerMovement.create({ data })
}</pre>
      </div>

      <h3>// service â€” reglas de negocio</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.service.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'
import {
  findAllWorkers, findWorkerById, findWorkerByDni,
  createWorker, updateWorker, createMovement
} from './workers.repository.js'
import { buildPagination } from '../../shared/utils/pagination.js'

export async function getAllWorkers(query) {
  const { data, total } = await findAllWorkers(query)
  return buildPagination(data, total, query.page, query.limit)
}

export async function getWorkerById(id) {
  const worker = await findWorkerById(id)
  if (!worker) {
    const err = new Error('Trabajador no encontrado')
    err.statusCode = 404
    throw err
  }
  return worker
}

export async function hireWorker(data, requestUser) {
  <span class="cm">// regla: el DNI debe ser Ãºnico</span>
  const existing = await findWorkerByDni(data.dni)
  if (existing) {
    const err = new Error(`Ya existe un trabajador con DNI ${data.dni}`)
    err.statusCode = 409
    throw err
  }

  <span class="cm">// transacciÃ³n: crear trabajador + registrar movimiento de ingreso</span>
  return prisma.$transaction(async (tx) => {
    const worker = await tx.worker.create({
      data: {
        firstName:  data.firstName,
        lastName:   data.lastName,
        dni:        data.dni,
        email:      data.email,
        phone:      data.phone,
        position:   data.position,
        department: data.department,
        salary:     data.salary,
        hireDate:   new Date(data.hireDate),
        status:     'ACTIVE'
      }
    })

    <span class="cm">// registrar el movimiento de ingreso en el historial</span>
    await tx.workerMovement.create({
      data: {
        workerId:      worker.id,
        type:          'HIRE',
        description:   `Ingreso como ${data.position} en ${data.department}`,
        newPosition:   data.position,
        effectiveDate: new Date(data.hireDate),
        createdBy:     requestUser.id
      }
    })

    return worker
  })
}

export async function updateWorkerInfo(id, data, requestUser) {
  const worker = await findWorkerById(id)
  if (!worker) {
    const err = new Error('Trabajador no encontrado')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// regla: no se puede editar un trabajador inactivo o renunciado</span>
  if (worker.status !== 'ACTIVE') {
    const err = new Error('No se puede editar un trabajador inactivo o renunciado')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// regla: DNI y fecha de ingreso NO son editables</span>
  <span class="cm">// son datos histÃ³ricos que no deben modificarse</span>
  const { dni, hireDate, ...editableData } = data
  if (dni || hireDate) {
    const err = new Error('El DNI y la fecha de ingreso no son editables')
    err.statusCode = 400
    throw err
  }

  return updateWorker(id, editableData)
}

export async function changePosition(id, data, requestUser) {
  const worker = await findWorkerById(id)
  if (!worker) {
    const err = new Error('Trabajador no encontrado')
    err.statusCode = 404
    throw err
  }

  if (worker.status !== 'ACTIVE') {
    const err = new Error('Solo se puede cambiar el cargo de un trabajador activo')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// regla: el nuevo cargo debe ser diferente al actual</span>
  if (worker.position === data.newPosition) {
    const err = new Error('El nuevo cargo es igual al cargo actual')
    err.statusCode = 400
    throw err
  }

  <span class="cm">// transacciÃ³n: actualizar cargo + registrar movimiento</span>
  return prisma.$transaction(async (tx) => {
    const updated = await tx.worker.update({
      where: { id },
      data: { position: data.newPosition }
    })

    await tx.workerMovement.create({
      data: {
        workerId:         id,
        type:             'POSITION_CHANGE',
        description:      data.reason || `Cambio de cargo`,
        previousPosition: worker.position,
        newPosition:      data.newPosition,
        effectiveDate:    new Date(data.effectiveDate),
        createdBy:        requestUser.id
      }
    })

    return updated
  })
}

export async function resignWorker(id, data, requestUser) {
  const worker = await findWorkerById(id)
  if (!worker) {
    const err = new Error('Trabajador no encontrado')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// regla: solo se puede renunciar si estÃ¡ activo</span>
  if (worker.status !== 'ACTIVE') {
    const err = new Error('El trabajador no estÃ¡ activo')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// transacciÃ³n: cambiar estado + registrar movimiento + desactivar acceso</span>
  return prisma.$transaction(async (tx) => {
    const updated = await tx.worker.update({
      where: { id },
      data: { status: 'RESIGNED' }
    })

    <span class="cm">// registrar la renuncia en el historial</span>
    await tx.workerMovement.create({
      data: {
        workerId:      id,
        type:          'RESIGN',
        description:   data.reason || 'Renuncia voluntaria',
        effectiveDate: new Date(data.effectiveDate),
        createdBy:     requestUser.id
      }
    })

    <span class="cm">// si tenÃ­a acceso al sistema, desactivarlo tambiÃ©n</span>
    if (worker.user) {
      await tx.user.update({
        where: { id: worker.user.id },
        data: { isActive: false }
      })
    }

    return updated
  })
}

export async function reactivateWorker(id, data, requestUser) {
  const worker = await findWorkerById(id)
  if (!worker) {
    const err = new Error('Trabajador no encontrado')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// regla: solo se puede reactivar si estÃ¡ renunciado o inactivo</span>
  if (worker.status === 'ACTIVE') {
    const err = new Error('El trabajador ya estÃ¡ activo')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// transacciÃ³n: reactivar + registrar reingreso</span>
  return prisma.$transaction(async (tx) => {
    const updated = await tx.worker.update({
      where: { id },
      data: {
        status:   'ACTIVE',
        position: data.newPosition || worker.position,
        salary:   data.newSalary   || worker.salary
      }
    })

    await tx.workerMovement.create({
      data: {
        workerId:      id,
        type:          'REACTIVATE',
        description:   data.reason || 'Reingreso a la empresa',
        newPosition:   data.newPosition || worker.position,
        effectiveDate: new Date(data.effectiveDate),
        createdBy:     requestUser.id
      }
    })

    return updated
  })
}

export async function toggleWorkerAccess(id, data, requestUser) {
  const worker = await findWorkerById(id)
  if (!worker) {
    const err = new Error('Trabajador no encontrado')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// si ya tiene usuario, activar/desactivar acceso</span>
  if (worker.user) {
    return prisma.user.update({
      where: { id: worker.user.id },
      data: { isActive: data.isActive, role: data.role || worker.user.role }
    })
  }

  <span class="cm">// si no tiene usuario, crear uno nuevo con acceso</span>
  if (data.isActive) {
    if (!data.password) {
      const err = new Error('Se requiere contraseÃ±a para crear acceso')
      err.statusCode = 400
      throw err
    }

    const bcrypt = await import('bcryptjs')
    const hashed = await bcrypt.hash(data.password, 12)

    return prisma.user.create({
      data: {
        name:     `${worker.firstName} ${worker.lastName}`,
        email:    worker.email,
        password: hashed,
        role:     data.role || 'USER',
        workerId: worker.id
      }
    })
  }
}</pre>
      </div>

      <h3>// controller</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.controller.js</span><span class="code-lang">js</span></div>
        <pre>import {
  getAllWorkers, getWorkerById, hireWorker, updateWorkerInfo,
  changePosition, resignWorker, reactivateWorker, toggleWorkerAccess
} from './workers.service.js'
import {
  hireWorkerSchema, updateWorkerSchema, changePositionSchema,
  resignSchema, reactivateSchema, workerAccessSchema, workersQuerySchema
} from './workers.schema.js'

export async function listWorkersHandler(request, reply) {
  const query = workersQuerySchema.parse(request.query)
  const result = await getAllWorkers(query)
  return reply.send(result)
}

export async function getWorkerHandler(request, reply) {
  const worker = await getWorkerById(request.params.id)
  return reply.send(worker)
}

export async function hireWorkerHandler(request, reply) {
  const body = hireWorkerSchema.parse(request.body)
  request.log.info({ createdBy: request.user.id }, 'Registrando nuevo trabajador')
  const worker = await hireWorker(body, request.user)
  request.log.info({ workerId: worker.id, dni: worker.dni }, 'Trabajador registrado')
  return reply.code(201).send(worker)
}

export async function updateWorkerHandler(request, reply) {
  const body = updateWorkerSchema.parse(request.body)
  const worker = await updateWorkerInfo(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function changePositionHandler(request, reply) {
  const body = changePositionSchema.parse(request.body)
  request.log.info({ workerId: request.params.id, newPosition: body.newPosition }, 'Cambiando cargo')
  const worker = await changePosition(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function resignWorkerHandler(request, reply) {
  const body = resignSchema.parse(request.body)
  request.log.info({ workerId: request.params.id }, 'Registrando renuncia')
  const worker = await resignWorker(request.params.id, body, request.user)
  request.log.info({ workerId: request.params.id }, 'Renuncia registrada')
  return reply.send(worker)
}

export async function reactivateWorkerHandler(request, reply) {
  const body = reactivateSchema.parse(request.body)
  request.log.info({ workerId: request.params.id }, 'Reactivando trabajador')
  const worker = await reactivateWorker(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function workerAccessHandler(request, reply) {
  const body = workerAccessSchema.parse(request.body)
  const result = await toggleWorkerAccess(request.params.id, body, request.user)
  return reply.send(result)
}</pre>
      </div>

      <h3>// schemas Zod</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.schema.js</span><span class="code-lang">js</span></div>
        <pre>import { z } from 'zod'

export const hireWorkerSchema = z.object({
  firstName:  z.string().min(2),
  lastName:   z.string().min(2),
  dni:        z.string().min(6).max(20),
  email:      z.string().email(),
  phone:      z.string().optional(),
  position:   z.string().min(2),
  department: z.string().min(2),
  salary:     z.number().positive(),
  hireDate:   z.string().datetime()
})

<span class="cm">// solo campos editables â€” DNI y hireDate NO estÃ¡n aquÃ­</span>
export const updateWorkerSchema = z.object({
  firstName:  z.string().min(2).optional(),
  lastName:   z.string().min(2).optional(),
  email:      z.string().email().optional(),
  phone:      z.string().optional(),
  department: z.string().min(2).optional(),
  salary:     z.number().positive().optional()
})

export const changePositionSchema = z.object({
  newPosition:   z.string().min(2),
  reason:        z.string().optional(),
  effectiveDate: z.string().datetime()
})

export const resignSchema = z.object({
  reason:        z.string().min(5),
  effectiveDate: z.string().datetime()
})

export const reactivateSchema = z.object({
  reason:        z.string().min(5),
  effectiveDate: z.string().datetime(),
  newPosition:   z.string().optional(),
  newSalary:     z.number().positive().optional()
})

export const workerAccessSchema = z.object({
  isActive: z.boolean(),
  role:     z.enum(['USER', 'ADMIN', 'RRHH', 'PRICING']).optional(),
  password: z.string().min(8).optional()
})

export const workersQuerySchema = z.object({
  page:       z.coerce.number().int().positive().default(1),
  limit:      z.coerce.number().int().positive().max(100).default(10),
  status:     z.enum(['ACTIVE', 'INACTIVE', 'RESIGNED']).optional(),
  department: z.string().optional()
})</pre>
      </div>

      <h3>// routes</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.routes.js</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { requireRole } from '../../shared/middlewares/roles.middleware.js'
import {
  listWorkersHandler, getWorkerHandler, hireWorkerHandler,
  updateWorkerHandler, changePositionHandler, resignWorkerHandler,
  reactivateWorkerHandler, workerAccessHandler
} from './workers.controller.js'

export async function workersRoutes(fastify) {

  <span class="cm">// GET /api/workers â€” ADMIN y RRHH pueden listar</span>
  fastify.get('/', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Listar trabajadores' }
  }, listWorkersHandler)

  <span class="cm">// GET /api/workers/:id â€” detalle con historial completo</span>
  fastify.get('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Obtener trabajador por ID' }
  }, getWorkerHandler)

  <span class="cm">// POST /api/workers â€” contratar nuevo trabajador</span>
  fastify.post('/', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Contratar trabajador' }
  }, hireWorkerHandler)

  <span class="cm">// PATCH /api/workers/:id â€” editar datos bÃ¡sicos</span>
  fastify.patch('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Editar datos del trabajador' }
  }, updateWorkerHandler)

  <span class="cm">// POST /api/workers/:id/position â€” cambiar cargo</span>
  fastify.post('/:id/position', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Cambiar cargo' }
  }, changePositionHandler)

  <span class="cm">// POST /api/workers/:id/resign â€” registrar renuncia</span>
  fastify.post('/:id/resign', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Registrar renuncia' }
  }, resignWorkerHandler)

  <span class="cm">// POST /api/workers/:id/reactivate â€” reingreso</span>
  fastify.post('/:id/reactivate', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Reactivar trabajador (reingreso)' }
  }, reactivateWorkerHandler)

  <span class="cm">// PATCH /api/workers/:id/access â€” gestionar acceso al sistema</span>
  fastify.patch('/:id/access', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Workers'], summary: 'Gestionar acceso al sistema (solo ADMIN)' }
  }, workerAccessHandler)
}</pre>
      </div>

      <h3>// module</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.module.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import { workersRoutes } from './workers.routes.js'

export const workersModule = fp(async (fastify) => {
  fastify.register(workersRoutes)
})</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js â€” registrar el mÃ³dulo</span><span class="code-lang">js</span></div>
        <pre>import { workersModule } from './modules/workers/workers.module.js'

app.register(workersModule, { prefix: '/api/workers' })</pre>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ”’</span>
        <div>
          <div class="callout-title">Campos no editables por diseÃ±o</div>
          <p>El <code>dni</code> y <code>hireDate</code> no aparecen en el <code>updateWorkerSchema</code> â€” si el cliente los envÃ­a, Zod los ignora. Son datos histÃ³ricos que identifican al trabajador y nunca deben modificarse.</p>
        </div>
      </div>

    </div>

    <!-- PASO 25: MÃ“DULO PRODUCTOS -->
    <div class="section" id="paso-25">
      <div class="section-header">
        <div class="step-number">25</div>
        <div>
          <div class="section-title">MÃ³dulo Productos</div>
          <div class="section-desc">GestiÃ³n de productos, control de stock con historial de movimientos y descuentos.</div>
        </div>
      </div>

      <h3>// estructura del mÃ³dulo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“ src/modules/products/</span><span class="code-lang">bash</span></div>
        <pre>products/
â”œâ”€â”€ products.module.js
â”œâ”€â”€ products.routes.js
â”œâ”€â”€ products.controller.js
â”œâ”€â”€ products.service.js
â”œâ”€â”€ products.repository.js
â””â”€â”€ products.schema.js</pre>
      </div>

      <h3>// repository</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.repository.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'

export async function findAllProducts({ page = 1, limit = 10, isActive } = {}) {
  const skip = (page - 1) * limit
  const where = {}
  if (isActive !== undefined) where.isActive = isActive

  const [data, total] = await Promise.all([
    prisma.product.findMany({
      where,
      skip,
      take: limit,
      include: {
        discounts: {
          where: { isActive: true },  <span class="cm">// solo descuentos activos</span>
          orderBy: { createdAt: 'desc' }
        }
      },
      orderBy: { name: 'asc' }
    }),
    prisma.product.count({ where })
  ])

  return { data, total }
}

export async function findProductById(id) {
  return prisma.product.findUnique({
    where: { id },
    include: {
      discounts:  { orderBy: { createdAt: 'desc' } },
      stockMoves: { orderBy: { createdAt: 'desc' }, take: 20 }
    }
  })
}

export async function findProductBySku(sku) {
  return prisma.product.findUnique({ where: { sku } })
}

export async function createProduct(data) {
  return prisma.product.create({ data })
}

export async function updateProduct(id, data) {
  return prisma.product.update({ where: { id }, data })
}

export async function createStockMovement(data) {
  return prisma.stockMovement.create({ data })
}

export async function createDiscount(data) {
  return prisma.discount.create({ data })
}

export async function updateDiscount(id, data) {
  return prisma.discount.update({ where: { id }, data })
}

export async function findDiscountById(id) {
  return prisma.discount.findUnique({
    where: { id },
    include: { product: { select: { id: true, name: true } } }
  })
}</pre>
      </div>

      <h3>// service â€” reglas de negocio</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.service.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'
import {
  findAllProducts, findProductById, findProductBySku,
  createProduct, updateProduct,
  createStockMovement, createDiscount, updateDiscount, findDiscountById
} from './products.repository.js'
import { buildPagination } from '../../shared/utils/pagination.js'

export async function getAllProducts(query) {
  const { data, total } = await findAllProducts(query)
  return buildPagination(data, total, query.page, query.limit)
}

export async function getProductById(id) {
  const product = await findProductById(id)
  if (!product) {
    const err = new Error('Producto no encontrado')
    err.statusCode = 404
    throw err
  }
  return product
}

export async function createNewProduct(data, requestUser) {
  <span class="cm">// regla: el SKU debe ser Ãºnico</span>
  const existing = await findProductBySku(data.sku)
  if (existing) {
    const err = new Error(`Ya existe un producto con SKU ${data.sku}`)
    err.statusCode = 409
    throw err
  }

  return createProduct(data)
}

export async function updateProductInfo(id, data, requestUser) {
  const product = await findProductById(id)
  if (!product) {
    const err = new Error('Producto no encontrado')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// regla: el SKU no es editable â€” identifica al producto</span>
  if (data.sku) {
    const err = new Error('El SKU no es editable')
    err.statusCode = 400
    throw err
  }

  return updateProduct(id, data)
}

export async function deactivateProduct(id, requestUser) {
  const product = await findProductById(id)
  if (!product) {
    const err = new Error('Producto no encontrado')
    err.statusCode = 404
    throw err
  }

  if (!product.isActive) {
    const err = new Error('El producto ya estÃ¡ desactivado')
    err.statusCode = 409
    throw err
  }

  return updateProduct(id, { isActive: false })
}

export async function adjustStock(id, data, requestUser) {
  const product = await findProductById(id)
  if (!product) {
    const err = new Error('Producto no encontrado')
    err.statusCode = 404
    throw err
  }

  if (!product.isActive) {
    const err = new Error('No se puede ajustar stock de un producto desactivado')
    err.statusCode = 409
    throw err
  }

  const newStock = product.stock + data.quantity

  <span class="cm">// regla: el stock nunca puede quedar negativo</span>
  if (newStock < 0) {
    const err = new Error(`Stock insuficiente. Disponible: ${product.stock}`)
    err.statusCode = 409
    throw err
  }

  <span class="cm">// transacciÃ³n: actualizar stock + registrar movimiento</span>
  return prisma.$transaction(async (tx) => {
    const updated = await tx.product.update({
      where: { id },
      data: { stock: newStock }
    })

    <span class="cm">// siempre guardar el historial del movimiento de stock</span>
    await tx.stockMovement.create({
      data: {
        productId:     id,
        type:          data.type,       <span class="cm">// IN, OUT, ADJUST, RETURN</span>
        quantity:      data.quantity,
        previousStock: product.stock,
        newStock:      newStock,
        reason:        data.reason,
        createdBy:     requestUser.id
      }
    })

    return updated
  })
}

export async function addDiscount(productId, data, requestUser) {
  const product = await findProductById(productId)
  if (!product) {
    const err = new Error('Producto no encontrado')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// regla: porcentaje entre 1 y 100</span>
  if (data.percentage <= 0 || data.percentage > 100) {
    const err = new Error('El porcentaje debe estar entre 1 y 100')
    err.statusCode = 400
    throw err
  }

  <span class="cm">// regla: la fecha de inicio debe ser antes que la de fin</span>
  if (new Date(data.startDate) >= new Date(data.endDate)) {
    const err = new Error('La fecha de inicio debe ser anterior a la fecha de fin')
    err.statusCode = 400
    throw err
  }

  return createDiscount({
    productId,
    name:       data.name,
    percentage: data.percentage,
    startDate:  new Date(data.startDate),
    endDate:    new Date(data.endDate),
    createdBy:  requestUser.id
  })
}

export async function deactivateDiscount(discountId, requestUser) {
  const discount = await findDiscountById(discountId)
  if (!discount) {
    const err = new Error('Descuento no encontrado')
    err.statusCode = 404
    throw err
  }

  if (!discount.isActive) {
    const err = new Error('El descuento ya estÃ¡ desactivado')
    err.statusCode = 409
    throw err
  }

  return updateDiscount(discountId, { isActive: false })
}</pre>
      </div>

      <h3>// controller</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.controller.js</span><span class="code-lang">js</span></div>
        <pre>import {
  getAllProducts, getProductById, createNewProduct, updateProductInfo,
  deactivateProduct, adjustStock, addDiscount, deactivateDiscount
} from './products.service.js'
import {
  createProductSchema, updateProductSchema, adjustStockSchema,
  addDiscountSchema, productsQuerySchema
} from './products.schema.js'

export async function listProductsHandler(request, reply) {
  const query = productsQuerySchema.parse(request.query)
  const result = await getAllProducts(query)
  return reply.send(result)
}

export async function getProductHandler(request, reply) {
  const product = await getProductById(request.params.id)
  return reply.send(product)
}

export async function createProductHandler(request, reply) {
  const body = createProductSchema.parse(request.body)
  request.log.info({ sku: body.sku, createdBy: request.user.id }, 'Creando producto')
  const product = await createNewProduct(body, request.user)
  request.log.info({ productId: product.id, sku: product.sku }, 'Producto creado')
  return reply.code(201).send(product)
}

export async function updateProductHandler(request, reply) {
  const body = updateProductSchema.parse(request.body)
  const product = await updateProductInfo(request.params.id, body, request.user)
  return reply.send(product)
}

export async function deactivateProductHandler(request, reply) {
  request.log.info({ productId: request.params.id, by: request.user.id }, 'Desactivando producto')
  const product = await deactivateProduct(request.params.id, request.user)
  return reply.send(product)
}

export async function adjustStockHandler(request, reply) {
  const body = adjustStockSchema.parse(request.body)
  request.log.info(
    { productId: request.params.id, quantity: body.quantity, type: body.type, by: request.user.id },
    'Ajuste de stock'
  )
  const product = await adjustStock(request.params.id, body, request.user)
  return reply.send(product)
}

export async function addDiscountHandler(request, reply) {
  const body = addDiscountSchema.parse(request.body)
  request.log.info({ productId: request.params.id, by: request.user.id }, 'Agregando descuento')
  const discount = await addDiscount(request.params.id, body, request.user)
  return reply.code(201).send(discount)
}

export async function deactivateDiscountHandler(request, reply) {
  request.log.info({ discountId: request.params.discountId, by: request.user.id }, 'Desactivando descuento')
  const discount = await deactivateDiscount(request.params.discountId, request.user)
  return reply.send(discount)
}</pre>
      </div>

      <h3>// schemas Zod</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.schema.js</span><span class="code-lang">js</span></div>
        <pre>import { z } from 'zod'

export const createProductSchema = z.object({
  name:        z.string().min(2),
  description: z.string().optional(),
  sku:         z.string().min(3).max(50),
  price:       z.number().positive(),
  stock:       z.number().int().min(0).default(0),
  minStock:    z.number().int().min(0).default(0),
  imageUrl:    z.string().url().optional()
})

<span class="cm">// SKU no estÃ¡ aquÃ­ â€” no es editable</span>
export const updateProductSchema = z.object({
  name:        z.string().min(2).optional(),
  description: z.string().optional(),
  price:       z.number().positive().optional(),
  minStock:    z.number().int().min(0).optional(),
  imageUrl:    z.string().url().optional()
})

export const adjustStockSchema = z.object({
  quantity: z.number().int().refine(n => n !== 0, 'La cantidad no puede ser 0'),
  type:     z.enum(['IN', 'OUT', 'ADJUST', 'RETURN']),
  reason:   z.string().min(5, 'El motivo debe tener al menos 5 caracteres')
})

export const addDiscountSchema = z.object({
  name:       z.string().min(3),
  percentage: z.number().positive().max(100),
  startDate:  z.string().datetime(),
  endDate:    z.string().datetime()
})

export const productsQuerySchema = z.object({
  page:     z.coerce.number().int().positive().default(1),
  limit:    z.coerce.number().int().positive().max(100).default(10),
  isActive: z.coerce.boolean().optional()
})</pre>
      </div>

      <h3>// routes</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.routes.js</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { requireRole } from '../../shared/middlewares/roles.middleware.js'
import {
  listProductsHandler, getProductHandler, createProductHandler,
  updateProductHandler, deactivateProductHandler,
  adjustStockHandler, addDiscountHandler, deactivateDiscountHandler
} from './products.controller.js'

export async function productsRoutes(fastify) {

  <span class="cm">// GET /api/products â€” cualquier usuario autenticado puede ver</span>
  fastify.get('/', {
    preHandler: [requireAuth],
    schema: { tags: ['Products'], summary: 'Listar productos' }
  }, listProductsHandler)

  <span class="cm">// GET /api/products/:id â€” detalle con descuentos y movimientos de stock</span>
  fastify.get('/:id', {
    preHandler: [requireAuth],
    schema: { tags: ['Products'], summary: 'Obtener producto por ID' }
  }, getProductHandler)

  <span class="cm">// POST /api/products â€” solo ADMIN</span>
  fastify.post('/', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Crear producto' }
  }, createProductHandler)

  <span class="cm">// PATCH /api/products/:id â€” solo ADMIN</span>
  fastify.patch('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Editar producto' }
  }, updateProductHandler)

  <span class="cm">// DELETE /api/products/:id â€” desactiva, no elimina</span>
  fastify.delete('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Desactivar producto' }
  }, deactivateProductHandler)

  <span class="cm">// POST /api/products/:id/stock â€” ajuste de stock</span>
  <span class="cm">// solo ADMIN puede hacer ajustes manuales</span>
  fastify.post('/:id/stock', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Ajustar stock' }
  }, adjustStockHandler)

  <span class="cm">// POST /api/products/:id/discounts â€” agregar descuento</span>
  <span class="cm">// ADMIN y PRICING pueden gestionar descuentos</span>
  fastify.post('/:id/discounts', {
    preHandler: [requireAuth, requireRole('ADMIN', 'PRICING')],
    schema: { tags: ['Products'], summary: 'Agregar descuento' }
  }, addDiscountHandler)

  <span class="cm">// DELETE /api/products/:id/discounts/:discountId â€” desactivar descuento</span>
  fastify.delete('/:id/discounts/:discountId', {
    preHandler: [requireAuth, requireRole('ADMIN', 'PRICING')],
    schema: { tags: ['Products'], summary: 'Desactivar descuento' }
  }, deactivateDiscountHandler)
}</pre>
      </div>

      <h3>// module</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.module.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import { productsRoutes } from './products.routes.js'

export const productsModule = fp(async (fastify) => {
  fastify.register(productsRoutes)
})</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js â€” registrar el mÃ³dulo</span><span class="code-lang">js</span></div>
        <pre>import { productsModule } from './modules/products/products.module.js'
import { workersModule } from './modules/workers/workers.module.js'

app.register(productsModule, { prefix: '/api/products' })
app.register(workersModule,  { prefix: '/api/workers' })</pre>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ“¦</span>
        <div>
          <div class="callout-title">SKU no editable por diseÃ±o</div>
          <p>El <code>sku</code> identifica de forma Ãºnica al producto en todo el sistema â€” en facturas, reportes, integraciones con otros sistemas. Si se editara, se romperÃ­a esa trazabilidad. Por eso no aparece en <code>updateProductSchema</code>.</p>
        </div>
      </div>

      <div class="callout warning">
        <span class="callout-icon">âš ï¸</span>
        <div>
          <div class="callout-title">Stock mÃ­nimo como alerta</div>
          <p>El campo <code>minStock</code> permite configurar un umbral de alerta. Puedes agregar lÃ³gica en el service para notificar cuando <code>stock &lt;= minStock</code> despuÃ©s de un ajuste o una venta.</p>
        </div>
      </div>

    </div>

    <!-- PASO 23: BUENAS PRÃCTICAS -->
    <div class="section" id="paso-23">
      <div class="section-header">
        <div class="step-number">23</div>
        <div>
          <div class="section-title">Buenas PrÃ¡cticas de Backend</div>
          <div class="section-desc">Todo lo que necesitas implementar para tener una API robusta, segura y mantenible.</div>
        </div>
      </div>

      <p>Una API en producciÃ³n no es solo que funcione â€” es que sea segura, predecible, trazable y resistente a fallos. Esta secciÃ³n consolida las prÃ¡cticas mÃ¡s importantes organizadas por categorÃ­a.</p>

      <!-- â”€â”€â”€ 1. CONSISTENCIA DE DATOS â”€â”€â”€ -->
      <h3>// 1. nunca dejar datos inconsistentes â€” transacciones</h3>
      <p>Cuando una operaciÃ³n toca mÃºltiples tablas, todas deben completarse o ninguna. Si algo falla en el medio, Prisma revierte todo automÃ¡ticamente.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.service.js â€” transacciÃ³n correcta</span><span class="code-lang">js</span></div>
        <pre>export async function createSale({ userId, items }) {
  return prisma.$transaction(async (tx) => {
    <span class="cm">// todas las operaciones usan tx, no prisma directamente</span>
    <span class="cm">// si cualquiera falla, todo se revierte</span>

    for (const item of items) {
      const product = await tx.product.findUnique({ where: { id: item.productId } })

      if (!product) {
        <span class="cm">// lanzar error dentro de la transacciÃ³n la cancela automÃ¡ticamente</span>
        const err = new Error(`Producto ${item.productId} no existe`)
        err.statusCode = 404
        throw err
      }

      if (product.stock < item.quantity) {
        const err = new Error(`Stock insuficiente para "${product.name}"`)
        err.statusCode = 409
        throw err
      }
    }

    const sale = await tx.sale.create({ ... })

    <span class="cm">// esto y lo de arriba son atÃ³micos â€” si falla aquÃ­, la venta no se crea</span>
    for (const item of items) {
      await tx.product.update({
        where: { id: item.productId },
        data: { stock: { decrement: item.quantity } }
      })
    }

    return sale
  })
}

<span class="cm">// âŒ NUNCA mezclar tx con prisma dentro de una transacciÃ³n</span>
<span class="cm">// esto NO estÃ¡ dentro de la transacciÃ³n y no se puede revertir:</span>
return prisma.$transaction(async (tx) => {
  await tx.sale.create(...)
  await prisma.product.update(...)  <span class="cm">// â† MAL, usa tx no prisma</span>
})</pre>
      </div>

      <!-- â”€â”€â”€ 2. ERRORES TIPADOS â”€â”€â”€ -->
      <h3>// 2. errores tipados con cÃ³digos HTTP correctos</h3>
      <p>Cada error debe tener un tipo claro y un cÃ³digo HTTP correcto. El cliente necesita saber si fue un error suyo (4xx) o del servidor (5xx).</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/errors/error-handler.js</span><span class="code-lang">js</span></div>
        <pre>export function errorHandler(error, request, reply) {
  const reqId = request.id

  <span class="cm">// 1. errores de validaciÃ³n Zod â€” siempre 400</span>
  if (error.name === 'ZodError') {
    return reply.code(400).send({
      statusCode: 400,
      error: 'Validation Error',
      message: 'Datos invÃ¡lidos',
      details: error.errors.map(e => ({
        field: e.path.join('.'),
        message: e.message
      }))
    })
  }

  <span class="cm">// 2. errores de negocio con statusCode â€” 4xx</span>
  if (error.statusCode) {
    return reply.code(error.statusCode).send({
      statusCode: error.statusCode,
      error: getErrorName(error.statusCode),
      message: error.message  <span class="cm">// mensaje descriptivo para el cliente</span>
    })
  }

  <span class="cm">// 3. errores de Prisma â€” mapear a HTTP</span>
  if (error.code === 'P2002') {
    return reply.code(409).send({
      statusCode: 409,
      error: 'Conflict',
      message: 'El recurso ya existe'
    })
  }

  if (error.code === 'P2025') {
    return reply.code(404).send({
      statusCode: 404,
      error: 'Not Found',
      message: 'Recurso no encontrado'
    })
  }

  <span class="cm">// 4. error inesperado â€” siempre 500</span>
  <span class="cm">// NUNCA exponer el stack trace ni detalles internos en producciÃ³n</span>
  request.log.error({ reqId, err: error }, 'Error inesperado')

  return reply.code(500).send({
    statusCode: 500,
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'production'
      ? 'Error interno del servidor'  <span class="cm">// â† producciÃ³n: mensaje genÃ©rico</span>
      : error.message                  <span class="cm">// â† desarrollo: mensaje real para debug</span>
    <span class="cm">// NUNCA incluir error.stack en producciÃ³n</span>
  })
}

function getErrorName(statusCode) {
  const names = {
    400: 'Bad Request',
    401: 'Unauthorized',
    403: 'Forbidden',
    404: 'Not Found',
    409: 'Conflict',
    422: 'Unprocessable Entity',
    429: 'Too Many Requests'
  }
  return names[statusCode] || 'Error'
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ cÃ³digos HTTP correctos por situaciÃ³n</span><span class="code-lang">bash</span></div>
        <pre>200 OK              â†’ GET exitoso, PATCH exitoso
201 Created         â†’ POST exitoso (recurso creado)
204 No Content      â†’ DELETE exitoso (sin body)
400 Bad Request     â†’ datos invÃ¡lidos, validaciÃ³n fallida
401 Unauthorized    â†’ sin token o token invÃ¡lido
403 Forbidden       â†’ token vÃ¡lido pero sin permisos
404 Not Found       â†’ recurso no existe
409 Conflict        â†’ email duplicado, stock insuficiente
422 Unprocessable   â†’ datos bien formados pero lÃ³gicamente invÃ¡lidos
429 Too Many Req.   â†’ rate limit superado
500 Server Error    â†’ error inesperado del servidor</pre>
      </div>

      <!-- â”€â”€â”€ 3. AUTORIZACIÃ“N REAL â”€â”€â”€ -->
      <h3>// 3. autorizaciÃ³n real â€” no solo autenticaciÃ³n</h3>
      <p>AutenticaciÃ³n verifica quiÃ©n eres. AutorizaciÃ³n verifica quÃ© puedes hacer. No basta con tener un token vÃ¡lido â€” debes verificar que tienes permiso sobre el recurso especÃ­fico.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.service.js</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âŒ solo autenticaciÃ³n â€” cualquier usuario autenticado puede modificar</span>
export async function updateSaleStatus(id, data, requestUser) {
  return updateSale(id, data)  <span class="cm">// â† peligroso, sin verificar propiedad</span>
}

<span class="cm">// âœ… autorizaciÃ³n real â€” verificar propiedad del recurso</span>
export async function updateSaleStatus(id, data, requestUser) {
  const sale = await findSaleById(id)

  if (!sale) {
    const err = new Error('Venta no encontrada')
    err.statusCode = 404
    throw err
  }

  <span class="cm">// verificar que el usuario es dueÃ±o O es admin</span>
  const isOwner = sale.userId === requestUser.id
  const isAdmin = requestUser.role === 'ADMIN'

  if (!isOwner && !isAdmin) {
    const err = new Error('No tienes permiso para modificar esta venta')
    err.statusCode = 403
    throw err
  }

  <span class="cm">// verificar estado de negocio</span>
  if (sale.status === 'COMPLETED') {
    const err = new Error('No se puede modificar una venta completada')
    err.statusCode = 409
    throw err
  }

  return updateSale(id, data)
}</pre>
      </div>

      <!-- â”€â”€â”€ 4. ÃNDICES EN BD â”€â”€â”€ -->
      <h3>// 4. Ã­ndices correctos en la base de datos</h3>
      <p>Sin Ã­ndices, cada consulta hace un <em>full table scan</em> â€” lee toda la tabla para encontrar un registro. Con Ã­ndices, PostgreSQL salta directamente al dato. Son crÃ­ticos para el rendimiento en tablas grandes.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prisma/schema.prisma â€” Ã­ndices</span><span class="code-lang">prisma</span></div>
        <pre>model User {
  id    String @id @default(uuid())
  email String @unique   <span class="cm">// @unique crea un Ã­ndice automÃ¡ticamente</span>
  role  Role   @default(USER)
}

model Sale {
  id        String   @id @default(uuid())
  userId    String
  status    SaleStatus
  createdAt DateTime @default(now())

  <span class="cm">// @@index crea Ã­ndices para campos que se consultan frecuentemente</span>
  @@index([userId])               <span class="cm">// buscar ventas por usuario</span>
  @@index([status])               <span class="cm">// filtrar por estado</span>
  @@index([createdAt])            <span class="cm">// ordenar por fecha</span>
  @@index([userId, status])       <span class="cm">// Ã­ndice compuesto â€” ventas de un usuario con estado</span>
}

model SaleItem {
  id        String @id @default(uuid())
  saleId    String
  productId String

  @@index([saleId])               <span class="cm">// buscar Ã­tems de una venta</span>
  @@index([productId])            <span class="cm">// buscar Ã­tems por producto</span>
}

<span class="cm">// regla: crear Ã­ndices en campos que usas en where, orderBy o join</span>
<span class="cm">// despuÃ©s de agregar Ã­ndices: npx prisma migrate dev --name add-indexes</span></pre>
      </div>

      <!-- â”€â”€â”€ 5. N+1 QUERIES â”€â”€â”€ -->
      <h3>// 5. evitar N+1 queries</h3>
      <p>El problema N+1 ocurre cuando haces 1 query para obtener una lista y luego N queries adicionales para obtener datos relacionados de cada elemento. Prisma lo resuelve con <code>include</code>.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.repository.js</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âŒ N+1 â€” 1 query para ventas + N queries para el usuario de cada venta</span>
const sales = await prisma.sale.findMany()
for (const sale of sales) {
  sale.user = await prisma.user.findUnique({ where: { id: sale.userId } })
  <span class="cm">// si hay 100 ventas â†’ 101 queries al servidor</span>
}

<span class="cm">// âœ… include â€” 1 sola query con JOIN optimizado</span>
const sales = await prisma.sale.findMany({
  include: {
    user:  { select: { id: true, name: true, email: true } },
    items: { include: { product: { select: { id: true, name: true, price: true } } } }
  }
})
<span class="cm">// 1 sola query sin importar cuÃ¡ntas ventas haya</span>

<span class="cm">// âœ… select para no traer datos innecesarios</span>
<span class="cm">// si solo necesitas el nombre, no traigas price, stock, description, etc.</span>
const products = await prisma.product.findMany({
  select: { id: true, name: true }  <span class="cm">// solo lo que necesitas</span>
})</pre>
      </div>

      <!-- â”€â”€â”€ 6. IDEMPOTENCIA â”€â”€â”€ -->
      <h3>// 6. idempotencia en operaciones crÃ­ticas</h3>
      <p>Una operaciÃ³n es idempotente cuando ejecutarla mÃºltiples veces produce el mismo resultado. Es crÃ­tico en pagos o creaciÃ³n de recursos donde el cliente puede reintentar por un error de red.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.service.js â€” idempotencia</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// el cliente envÃ­a un idempotencyKey Ãºnico por operaciÃ³n</span>
<span class="cm">// si el cliente reintenta con el mismo key, devolvemos la venta ya creada</span>
export async function createSale({ userId, items, idempotencyKey }) {
  <span class="cm">// buscar si ya existe una venta con este key</span>
  if (idempotencyKey) {
    const existing = await prisma.sale.findFirst({
      where: { idempotencyKey, userId }
    })
    <span class="cm">// si ya existe, devolver la misma venta sin crear otra</span>
    if (existing) return existing
  }

  return prisma.$transaction(async (tx) => {
    <span class="cm">// ... validaciones de stock ...</span>

    const sale = await tx.sale.create({
      data: {
        userId,
        total,
        idempotencyKey,  <span class="cm">// guardar el key en la venta</span>
        items: { create: saleItems }
      }
    })

    <span class="cm">// ... descuento de stock ...</span>
    return sale
  })
}

<span class="cm">// el schema.prisma necesita el campo y un Ã­ndice Ãºnico</span>
<span class="cm">// model Sale {</span>
<span class="cm">//   idempotencyKey String?  @unique</span>
<span class="cm">// }</span></pre>
      </div>

      <!-- â”€â”€â”€ 7. HASH DE CONTRASEÃ‘AS â”€â”€â”€ -->
      <h3>// 7. hash correcto de contraseÃ±as</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/auth/auth.service.js</span><span class="code-lang">js</span></div>
        <pre>import bcrypt from 'bcryptjs'

<span class="cm">// âœ… siempre hashear con bcrypt â€” salt rounds 12 para producciÃ³n</span>
<span class="cm">// mÃ¡s rounds = mÃ¡s seguro pero mÃ¡s lento (12 es el balance correcto)</span>
const hashed = await bcrypt.hash(password, 12)

<span class="cm">// âœ… compare en tiempo constante â€” previene timing attacks</span>
<span class="cm">// un atacante podrÃ­a medir el tiempo de respuesta para adivinar contraseÃ±as</span>
<span class="cm">// bcrypt.compare siempre tarda lo mismo sin importar si es correcto o no</span>
const valid = user && await bcrypt.compare(password, user.password)
if (!valid) {
  <span class="cm">// mismo mensaje para usuario inexistente o contraseÃ±a incorrecta</span>
  <span class="cm">// no le digas al atacante cuÃ¡l de los dos fallÃ³</span>
  const err = new Error('Credenciales invÃ¡lidas')
  err.statusCode = 401
  throw err
}

<span class="cm">// âŒ NUNCA</span>
const hashed = md5(password)          <span class="cm">// MD5 no es seguro para contraseÃ±as</span>
const hashed = sha256(password)       <span class="cm">// SHA tampoco â€” demasiado rÃ¡pido</span>
const hashed = password               <span class="cm">// texto plano â€” catastrÃ³fico</span></pre>
      </div>

      <!-- â”€â”€â”€ 8. TOKENS â”€â”€â”€ -->
      <h3>// 8. manejo correcto de tokens JWT</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ manejo de tokens</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âœ… JWT_SECRET debe ser largo y aleatorio â€” mÃ­nimo 32 caracteres</span>
JWT_SECRET=k9#mP2$xQr8vL5nW3jZ6bY1cU4hD7fA0s  <span class="cm">// en .env</span>

<span class="cm">// âœ… tiempo de expiraciÃ³n razonable</span>
JWT_EXPIRES_IN=7d    <span class="cm">// 7 dÃ­as para web</span>
JWT_EXPIRES_IN=24h   <span class="cm">// 24 horas para mayor seguridad</span>
JWT_EXPIRES_IN=15m   <span class="cm">// 15 min con refresh token para apps crÃ­ticas</span>

<span class="cm">// âœ… el token solo guarda lo necesario â€” sin datos sensibles</span>
fastify.jwt.sign({
  id:    user.id,
  email: user.email,
  role:  user.role
  <span class="cm">// NUNCA incluir: password, tokens de terceros, datos bancarios</span>
})

<span class="cm">// âœ… verificar el token en requireAuth antes de cualquier operaciÃ³n</span>
export async function requireAuth(request, reply) {
  try {
    await request.jwtVerify()
    <span class="cm">// si el token expirÃ³ â†’ jwtVerify lanza error â†’ 401</span>
  } catch {
    reply.code(401).send({ statusCode: 401, message: 'Token invÃ¡lido o expirado' })
  }
}

<span class="cm">// âŒ NUNCA</span>
<span class="cm">// exponer el JWT_SECRET en logs o respuestas</span>
<span class="cm">// guardar tokens en la BD sin cifrar</span>
<span class="cm">// confiar en el payload del token sin verificar la firma</span></pre>
      </div>

      <!-- â”€â”€â”€ 9. SANITIZACIÃ“N â”€â”€â”€ -->
      <h3>// 9. sanitizaciÃ³n de entrada</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/utils/sanitize.js</span><span class="code-lang">js</span></div>
        <pre>export function sanitizeQuery(query) {
  const result = {}
  for (const [key, value] of Object.entries(query)) {
    if (typeof value === 'string') {
      result[key] = value
        .replace(/[<>'"`;\\]/g, '')  <span class="cm">// eliminar caracteres peligrosos</span>
        .trim()                        <span class="cm">// eliminar espacios sobrantes</span>
        .slice(0, 200)                 <span class="cm">// limitar longitud mÃ¡xima</span>
    } else {
      result[key] = value
    }
  }
  return result
}

<span class="cm">// âœ… siempre sanitizar query params antes de Zod</span>
const query = getSalesQuerySchema.parse(sanitizeQuery(request.query))

<span class="cm">// el body ya estÃ¡ protegido por Zod â€” solo acepta los campos definidos</span>
<span class="cm">// cualquier campo extra en el body es ignorado automÃ¡ticamente por Zod</span>
<span class="cm">// { items: [...], malicious: "DROP TABLE" } â†’ malicious es ignorado</span></pre>
      </div>

      <!-- â”€â”€â”€ 10. LOGS Y TRAZABILIDAD â”€â”€â”€ -->
      <h3>// 10. logs de operaciones importantes y trazabilidad</h3>
      <p>Cuando algo falla en producciÃ³n, los logs son tu Ãºnica herramienta para entender quÃ© pasÃ³. Cada peticiÃ³n tiene un <code>reqId</code> Ãºnico que conecta todos los logs de esa peticiÃ³n.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.controller.js â€” logs correctos</span><span class="code-lang">js</span></div>
        <pre>export async function createSaleHandler(request, reply) {
  const body = createSaleSchema.parse(request.body)

  <span class="cm">// log de inicio â€” quiÃ©n hace quÃ©</span>
  request.log.info(
    { userId: request.user.id, itemCount: body.items.length },
    'Iniciando creaciÃ³n de venta'
  )

  const sale = await createSale({ userId: request.user.id, items: body.items })

  <span class="cm">// log de Ã©xito â€” quÃ© se creÃ³</span>
  request.log.info(
    { userId: request.user.id, saleId: sale.id, total: sale.total },
    'Venta creada exitosamente'
  )

  return reply.code(201).send(sale)
}

<span class="cm">// los logs automÃ¡ticamente incluyen reqId â€” trazabilidad entre capas</span>
<span class="cm">// en producciÃ³n todos los logs de una peticiÃ³n comparten el mismo reqId:</span>
<span class="cm">// { "reqId": "req-1", "msg": "Iniciando creaciÃ³n de venta", "userId": "abc" }</span>
<span class="cm">// { "reqId": "req-1", "msg": "Venta creada exitosamente", "saleId": "xyz" }</span>
<span class="cm">// { "reqId": "req-1", "msg": "Error inesperado", "err": { ... } }</span></pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ quÃ© loguear y con quÃ© nivel</span><span class="code-lang">js</span></div>
        <pre>request.log.info(...)   <span class="cm">// operaciones exitosas importantes</span>
request.log.warn(...)   <span class="cm">// situaciones inusuales pero no errores</span>
request.log.error(...)  <span class="cm">// errores inesperados que necesitan atenciÃ³n</span>

<span class="cm">// âœ… loguear siempre</span>
<span class="cm">// login exitoso y fallido (con IP pero sin password)</span>
<span class="cm">// creaciÃ³n de recursos importantes</span>
<span class="cm">// errores 500 con contexto completo</span>
<span class="cm">// operaciones administrativas</span>

<span class="cm">// âŒ NUNCA loguear</span>
<span class="cm">// passwords, tokens JWT, tarjetas de crÃ©dito</span>
<span class="cm">// datos personales sensibles</span>
<span class="cm">// stack traces completos en producciÃ³n</span></pre>
      </div>

      <!-- â”€â”€â”€ 11. NO EXPONER STACK TRACES â”€â”€â”€ -->
      <h3>// 11. no exponer stack traces en producciÃ³n</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/shared/errors/error-handler.js</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âŒ exponer stack trace â€” da informaciÃ³n valiosa a atacantes</span>
return reply.code(500).send({
  message: error.message,
  stack: error.stack   <span class="cm">// â† NUNCA en producciÃ³n</span>
})

<span class="cm">// âœ… mensaje genÃ©rico en producciÃ³n, detalle en desarrollo</span>
return reply.code(500).send({
  statusCode: 500,
  error: 'Internal Server Error',
  message: process.env.NODE_ENV === 'production'
    ? 'Error interno del servidor'
    : error.message
})

<span class="cm">// el stack trace va a los LOGS del servidor, no al cliente</span>
request.log.error({ err: error, reqId: request.id }, 'Error inesperado')</pre>
      </div>

      <!-- â”€â”€â”€ 12. PAGINACIÃ“N OBLIGATORIA â”€â”€â”€ -->
      <h3>// 12. paginaciÃ³n obligatoria en listas</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/sales/sales.repository.js</span><span class="code-lang">js</span></div>
        <pre><span class="cm">// âŒ sin paginaciÃ³n â€” puede devolver millones de registros</span>
return prisma.sale.findMany()

<span class="cm">// âœ… siempre paginar con lÃ­mite mÃ¡ximo</span>
export async function findAllSales({ page = 1, limit = 10 } = {}) {
  const skip = (page - 1) * limit

  const [data, total] = await Promise.all([
    prisma.sale.findMany({ skip, take: limit, orderBy: { createdAt: 'desc' } }),
    prisma.sale.count()
  ])

  return { data, total }
}

<span class="cm">// en el schema Zod limitar el mÃ¡ximo de items por pÃ¡gina</span>
limit: z.coerce.number().int().positive().max(100).default(10)
<span class="cm">// asÃ­ nadie puede pedir 10000 registros de una vez</span></pre>
      </div>

      <!-- â”€â”€â”€ RESUMEN CHECKLIST â”€â”€â”€ -->
      <h3>// checklist completo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ antes de pasar a producciÃ³n</span><span class="code-lang">bash</span></div>
        <pre>DATOS
  âœ… transacciones en operaciones multi-tabla (usando tx, no prisma)
  âœ… Ã­ndices en campos usados en where, orderBy y join
  âœ… paginaciÃ³n en todos los endpoints de listado
  âœ… select/include para no traer datos innecesarios
  âœ… idempotencyKey en operaciones crÃ­ticas como pagos

SEGURIDAD
  âœ… bcrypt con salt rounds 12 para contraseÃ±as
  âœ… JWT_SECRET largo y aleatorio en .env
  âœ… requireAuth en todas las rutas protegidas
  âœ… verificaciÃ³n de propiedad del recurso en el service
  âœ… requireRole para endpoints administrativos
  âœ… rate limiting global y estricto en login
  âœ… CORS con orÃ­genes explÃ­citos en producciÃ³n
  âœ… sanitizaciÃ³n de query params
  âœ… Zod validando body en todos los POST/PATCH

ERRORES
  âœ… errorHandler global registrado en app.js
  âœ… cÃ³digos HTTP correctos por situaciÃ³n
  âœ… mensajes claros sin detalles internos en producciÃ³n
  âœ… stack traces solo en logs, nunca en respuesta al cliente
  âœ… errores de Prisma mapeados a HTTP legibles

OBSERVABILIDAD
  âœ… logs de operaciones importantes con contexto
  âœ… reqId en todos los logs para trazabilidad
  âœ… nunca loguear passwords ni tokens
  âœ… nivel de log correcto (info, warn, error)</pre>
      </div>

    </div>

    <!-- PASO 22: RESUMEN -->
    <div class="section" id="paso-22">
      <div class="section-header">
        <div class="step-number">22</div>
        <div>
          <div class="section-title">Resumen â€” Flujo Completo</div>
          <div class="section-desc">Una peticiÃ³n de punta a punta.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ POST /api/sales â€” flujo completo</span><span class="code-lang">flow</span></div>
        <pre>POST /api/sales
  â†“
1. @fastify/rate-limit     â†’ Â¿superÃ³ el lÃ­mite de IP?
  â†“
2. CORS plugin             â†’ Â¿origen permitido?
  â†“
3. sales.routes.js         â†’ preHandler: [requireAuth]
  â†“
4. auth.middleware.js      â†’ verifica JWT â†’ popula request.user
  â†“
5. sales.controller.js     â†’ extrae request.body
  â†“
6. sales.schema.js (Zod)   â†’ valida el body
  â†“ error â†’ ZodError â†’ errorHandler â†’ 400
7. sales.service.js        â†’ verifica stock, calcula total
  â†“ error â†’ statusCode 404/409 â†’ errorHandler
8. prisma.$transaction()   â†’ crea venta + descuenta stock (atÃ³mico)
  â†“ error â†’ P2002/P2025 â†’ errorHandler
9. redis.del(`sale:...`)   â†’ invalida cachÃ© si aplica
  â†“
10. pino log               â†’ registra la operaciÃ³n con request-id
  â†“
11. reply.code(201).send() â†’ respuesta al cliente</pre>
      </div>

      <div class="grid-2">
        <div class="card">
          <h4>ğŸ§± SeparaciÃ³n real de capas</h4>
          <p>Routes registra. Controller maneja HTTP. Service contiene reglas. Repository ejecuta queries. Cada funciÃ³n hace una sola cosa.</p>
        </div>
        <div class="card">
          <h4>ğŸ”’ Seguridad en capas</h4>
          <p>JWT autentica. requireRole autoriza. Zod valida. Prisma previene SQL injection. Rate limiting previene abuso.</p>
        </div>
        <div class="card">
          <h4>âš¡ Sin clases, sin TypeScript</h4>
          <p>Todo son funciones exportadas. Simple de leer, testear y escalar. El mismo patrÃ³n que usa Fastify internamente.</p>
        </div>
        <div class="card">
          <h4>ğŸ“¦ MÃ³dulos independientes</h4>
          <p>Cada dominio (sales, auth, products, orders) vive en su carpeta con sus 4 capas. Agregar uno nuevo no toca los demÃ¡s.</p>
        </div>
      </div>

    </div>

    </div>

  </div><!-- /content -->

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- MÃ“DULO TRABAJADORES                                  -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="content" id="workers-module">

    <!-- W1: SCHEMA + ROLES -->
    <div class="section" id="workers-schema">
      <div class="section-header">
        <div class="step-number">W1</div>
        <div>
          <div class="section-title">MÃ³dulo Trabajadores â€” Schema + Roles</div>
          <div class="section-desc">Entidades, roles extendidos, historial de movimientos y acceso al sistema.</div>
        </div>
      </div>

      <p>El mÃ³dulo de trabajadores maneja el ciclo de vida completo del personal: ingreso, cambio de cargo, renuncia y reingreso. Cada movimiento queda registrado en un historial. AdemÃ¡s, un trabajador puede o no tener acceso al aplicativo como usuario del sistema.</p>

      <h3>// 1. roles extendidos en Prisma</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prisma/schema.prisma â€” roles actualizados</span><span class="code-lang">prisma</span></div>
        <pre>enum Role {
  USER      <span class="cm">// acceso bÃ¡sico al aplicativo</span>
  ADMIN     <span class="cm">// acceso total</span>
  RRHH      <span class="cm">// gestiÃ³n de trabajadores y movimientos</span>
  PRICING   <span class="cm">// gestiÃ³n de precios y descuentos</span>
}</pre>
      </div>

      <h3>// 2. entidades del mÃ³dulo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prisma/schema.prisma â€” trabajadores</span><span class="code-lang">prisma</span></div>
        <pre><span class="cm">// Entity: Worker â€” representa un trabajador real</span>
model Worker {
  id          String        @id @default(uuid())
  firstName   String
  lastName    String
  email       String        @unique
  phone       String?
  dni         String        @unique        <span class="cm">// documento de identidad â€” nunca cambia</span>
  position    String                       <span class="cm">// cargo actual</span>
  department  String
  salary      Decimal       @db.Decimal(10, 2)
  startDate   DateTime                     <span class="cm">// fecha de ingreso original</span>
  status      WorkerStatus  @default(ACTIVE)

  <span class="cm">// acceso al aplicativo â€” un trabajador puede o no ser usuario</span>
  userId      String?       @unique        <span class="cm">// null = sin acceso al sistema</span>
  user        User?         @relation(fields: [userId], references: [id])

  movements   WorkerMovement[]             <span class="cm">// historial de movimientos</span>
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([status])
  @@index([department])
  @@index([dni])
  @@map("workers")
}

<span class="cm">// Entity: WorkerMovement â€” historial inmutable de cada evento del trabajador</span>
model WorkerMovement {
  id          String        @id @default(uuid())
  workerId    String
  worker      Worker        @relation(fields: [workerId], references: [id])
  type        MovementType                 <span class="cm">// tipo de movimiento</span>
  description String                       <span class="cm">// detalle del movimiento</span>
  previousPosition String?                 <span class="cm">// cargo anterior si hubo cambio</span>
  newPosition      String?                 <span class="cm">// cargo nuevo si hubo cambio</span>
  previousSalary   Decimal? @db.Decimal(10, 2)
  newSalary        Decimal? @db.Decimal(10, 2)
  effectiveDate    DateTime                <span class="cm">// cuÃ¡ndo aplicÃ³ el movimiento</span>
  createdBy   String                       <span class="cm">// userId de quien registrÃ³ el movimiento</span>
  createdAt   DateTime      @default(now())

  @@index([workerId])
  @@index([type])
  @@map("worker_movements")
}

enum WorkerStatus {
  ACTIVE      <span class="cm">// trabajando actualmente</span>
  INACTIVE    <span class="cm">// dado de baja temporalmente</span>
  RESIGNED    <span class="cm">// renunciÃ³</span>
  TERMINATED  <span class="cm">// despedido</span>
}

enum MovementType {
  HIRE              <span class="cm">// ingreso inicial</span>
  POSITION_CHANGE   <span class="cm">// cambio de cargo</span>
  SALARY_CHANGE     <span class="cm">// cambio de salario</span>
  DEPARTMENT_CHANGE <span class="cm">// cambio de departamento</span>
  RESIGNATION       <span class="cm">// renuncia</span>
  TERMINATION       <span class="cm">// despido</span>
  REENTRY           <span class="cm">// reingreso</span>
  DEACTIVATE        <span class="cm">// desactivaciÃ³n temporal</span>
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npx prisma migrate dev --name add-workers-module
npx prisma generate</pre>
      </div>

      <h3>// 3. schemas de validaciÃ³n Zod</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.schema.js</span><span class="code-lang">js</span></div>
        <pre>import { z } from 'zod'

<span class="cm">// DTO: crear trabajador</span>
export const createWorkerSchema = z.object({
  firstName:  z.string().min(2).max(100),
  lastName:   z.string().min(2).max(100),
  email:      z.string().email('Email invÃ¡lido'),
  phone:      z.string().optional(),
  dni:        z.string().min(5).max(20),
  position:   z.string().min(2).max(100),
  department: z.string().min(2).max(100),
  salary:     z.number().positive('El salario debe ser mayor a 0'),
  startDate:  z.coerce.date(),
  <span class="cm">// opcional: asignar acceso al sistema al crear</span>
  createUser: z.boolean().default(false),
  role:       z.enum(['USER', 'RRHH', 'PRICING']).optional()
})

<span class="cm">// DTO: editar datos editables â€” dni y startDate nunca se editan</span>
export const updateWorkerSchema = z.object({
  firstName:  z.string().min(2).max(100).optional(),
  lastName:   z.string().min(2).max(100).optional(),
  email:      z.string().email().optional(),
  phone:      z.string().optional(),
  department: z.string().optional()
  <span class="cm">// position y salary se cambian solo con movimientos formales</span>
  <span class="cm">// dni y startDate son inmutables â€” no estÃ¡n en este schema</span>
})

<span class="cm">// DTO: cambio de cargo â€” requiere descripciÃ³n para el historial</span>
export const positionChangeSchema = z.object({
  position:      z.string().min(2).max(100),
  department:    z.string().optional(),
  description:   z.string().min(10, 'Describe el motivo del cambio'),
  effectiveDate: z.coerce.date()
})

<span class="cm">// DTO: cambio de salario</span>
export const salaryChangeSchema = z.object({
  salary:        z.number().positive(),
  description:   z.string().min(10, 'Describe el motivo del cambio'),
  effectiveDate: z.coerce.date()
})

<span class="cm">// DTO: renuncia o despido</span>
export const exitSchema = z.object({
  type:          z.enum(['RESIGNATION', 'TERMINATION']),
  description:   z.string().min(10, 'Describe el motivo de la salida'),
  effectiveDate: z.coerce.date()
})

<span class="cm">// DTO: reingreso</span>
export const reentrySchema = z.object({
  position:      z.string().min(2).max(100),
  department:    z.string().min(2).max(100),
  salary:        z.number().positive(),
  description:   z.string().min(10, 'Describe el motivo del reingreso'),
  effectiveDate: z.coerce.date()
})

<span class="cm">// DTO: gestionar acceso al sistema</span>
export const systemAccessSchema = z.object({
  grantAccess: z.boolean(),
  role:        z.enum(['USER', 'RRHH', 'PRICING']).optional()
})

<span class="cm">// DTO: query params para listado</span>
export const getWorkersQuerySchema = z.object({
  page:       z.coerce.number().int().positive().default(1),
  limit:      z.coerce.number().int().positive().max(100).default(10),
  status:     z.enum(['ACTIVE', 'INACTIVE', 'RESIGNED', 'TERMINATED']).optional(),
  department: z.string().optional(),
  search:     z.string().optional()  <span class="cm">// buscar por nombre o dni</span>
})</pre>
      </div>
    </div>

    <!-- W2: REPOSITORY -->
    <div class="section" id="workers-repository">
      <div class="section-header">
        <div class="step-number">W2</div>
        <div>
          <div class="section-title">MÃ³dulo Trabajadores â€” Repository</div>
          <div class="section-desc">Consultas a la base de datos. Sin lÃ³gica de negocio.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.repository.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'

export async function findAllWorkers({ page = 1, limit = 10, status, department, search } = {}) {
  const skip = (page - 1) * limit
  const where = {}

  if (status)     where.status = status
  if (department) where.department = department

  <span class="cm">// bÃºsqueda por nombre o DNI</span>
  if (search) {
    where.OR = [
      { firstName: { contains: search, mode: 'insensitive' } },
      { lastName:  { contains: search, mode: 'insensitive' } },
      { dni:       { contains: search } }
    ]
  }

  const [data, total] = await Promise.all([
    prisma.worker.findMany({
      where,
      skip,
      take: limit,
      select: {
        id: true, firstName: true, lastName: true,
        email: true, dni: true, position: true,
        department: true, status: true, startDate: true,
        <span class="cm">// incluir si tiene acceso al sistema</span>
        user: { select: { id: true, role: true } }
      },
      orderBy: { lastName: 'asc' }
    }),
    prisma.worker.count({ where })
  ])

  return { data, total }
}

export async function findWorkerById(id) {
  return prisma.worker.findUnique({
    where: { id },
    include: {
      user:      { select: { id: true, email: true, role: true } },
      movements: { orderBy: { createdAt: 'desc' } }
    }
  })
}

export async function findWorkerByDni(dni) {
  return prisma.worker.findUnique({ where: { dni } })
}

export async function findWorkerByEmail(email) {
  return prisma.worker.findUnique({ where: { email } })
}

export async function createWorker(data) {
  return prisma.worker.create({ data })
}

export async function updateWorker(id, data) {
  return prisma.worker.update({ where: { id }, data })
}

export async function createMovement(data) {
  return prisma.workerMovement.create({ data })
}

export async function findMovementsByWorker(workerId) {
  return prisma.workerMovement.findMany({
    where: { workerId },
    orderBy: { effectiveDate: 'desc' }
  })
}</pre>
      </div>
    </div>

    <!-- W3: SERVICE -->
    <div class="section" id="workers-service">
      <div class="section-header">
        <div class="step-number">W3</div>
        <div>
          <div class="section-title">MÃ³dulo Trabajadores â€” Service</div>
          <div class="section-desc">Reglas de negocio, movimientos, historial y gestiÃ³n de acceso al sistema.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.service.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'
import bcrypt from 'bcryptjs'
import {
  findAllWorkers, findWorkerById, findWorkerByDni,
  findWorkerByEmail, createWorker, updateWorker,
  createMovement
} from './workers.repository.js'
import { buildPagination } from '../../shared/utils/pagination.js'

export async function getAllWorkers(query) {
  const { data, total } = await findAllWorkers(query)
  return buildPagination(data, total, query.page, query.limit)
}

export async function getWorkerById(id) {
  const worker = await findWorkerById(id)
  if (!worker) {
    const err = new Error('Trabajador no encontrado')
    err.statusCode = 404
    throw err
  }
  return worker
}

export async function createNewWorker(data, requestUser) {
  <span class="cm">// regla: DNI debe ser Ãºnico</span>
  const existingDni = await findWorkerByDni(data.dni)
  if (existingDni) {
    const err = new Error('Ya existe un trabajador con ese DNI')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// regla: email debe ser Ãºnico</span>
  const existingEmail = await findWorkerByEmail(data.email)
  if (existingEmail) {
    const err = new Error('Ya existe un trabajador con ese email')
    err.statusCode = 409
    throw err
  }

  return prisma.$transaction(async (tx) => {
    <span class="cm">// crear el trabajador</span>
    const { createUser, role, ...workerData } = data
    const worker = await tx.worker.create({ data: workerData })

    <span class="cm">// registrar movimiento HIRE en el historial</span>
    await tx.workerMovement.create({
      data: {
        workerId:      worker.id,
        type:          'HIRE',
        description:   'Ingreso inicial al sistema',
        newPosition:   worker.position,
        newSalary:     worker.salary,
        effectiveDate: worker.startDate,
        createdBy:     requestUser.id
      }
    })

    <span class="cm">// opcional: crear usuario del sistema al mismo tiempo</span>
    if (createUser && role) {
      const tempPassword = await bcrypt.hash('Cambiar123!', 12)
      const user = await tx.user.create({
        data: {
          name:     `${worker.firstName} ${worker.lastName}`,
          email:    worker.email,
          password: tempPassword,
          role
        }
      })
      await tx.worker.update({
        where: { id: worker.id },
        data:  { userId: user.id }
      })
    }

    return findWorkerById(worker.id)
  })
}

export async function editWorker(id, data, requestUser) {
  const worker = await getWorkerById(id)

  <span class="cm">// regla: solo trabajadores activos se pueden editar</span>
  if (worker.status !== 'ACTIVE') {
    const err = new Error('Solo se pueden editar trabajadores activos')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// regla: email Ãºnico si cambia</span>
  if (data.email && data.email !== worker.email) {
    const existing = await findWorkerByEmail(data.email)
    if (existing) {
      const err = new Error('Ya existe un trabajador con ese email')
      err.statusCode = 409
      throw err
    }
  }

  <span class="cm">// dni y startDate son inmutables â€” nunca se tocan aquÃ­</span>
  return updateWorker(id, data)
}

export async function changePosition(id, data, requestUser) {
  const worker = await getWorkerById(id)

  <span class="cm">// regla: solo activos pueden cambiar de cargo</span>
  if (worker.status !== 'ACTIVE') {
    const err = new Error('Solo se puede cambiar el cargo de un trabajador activo')
    err.statusCode = 409
    throw err
  }

  return prisma.$transaction(async (tx) => {
    <span class="cm">// registrar movimiento antes de actualizar</span>
    await tx.workerMovement.create({
      data: {
        workerId:         id,
        type:             'POSITION_CHANGE',
        description:      data.description,
        previousPosition: worker.position,
        newPosition:      data.position,
        effectiveDate:    data.effectiveDate,
        createdBy:        requestUser.id
      }
    })

    <span class="cm">// actualizar el cargo actual</span>
    return tx.worker.update({
      where: { id },
      data: {
        position:   data.position,
        department: data.department ?? worker.department
      }
    })
  })
}

export async function changeSalary(id, data, requestUser) {
  const worker = await getWorkerById(id)

  if (worker.status !== 'ACTIVE') {
    const err = new Error('Solo se puede cambiar el salario de un trabajador activo')
    err.statusCode = 409
    throw err
  }

  return prisma.$transaction(async (tx) => {
    await tx.workerMovement.create({
      data: {
        workerId:       id,
        type:           'SALARY_CHANGE',
        description:    data.description,
        previousSalary: worker.salary,
        newSalary:      data.salary,
        effectiveDate:  data.effectiveDate,
        createdBy:      requestUser.id
      }
    })

    return tx.worker.update({ where: { id }, data: { salary: data.salary } })
  })
}

export async function exitWorker(id, data, requestUser) {
  const worker = await getWorkerById(id)

  <span class="cm">// regla: no se puede dar de baja a alguien que ya saliÃ³</span>
  if (['RESIGNED', 'TERMINATED'].includes(worker.status)) {
    const err = new Error('El trabajador ya no estÃ¡ activo en la empresa')
    err.statusCode = 409
    throw err
  }

  const newStatus = data.type === 'RESIGNATION' ? 'RESIGNED' : 'TERMINATED'

  return prisma.$transaction(async (tx) => {
    <span class="cm">// registrar el movimiento de salida</span>
    await tx.workerMovement.create({
      data: {
        workerId:      id,
        type:          data.type,
        description:   data.description,
        effectiveDate: data.effectiveDate,
        createdBy:     requestUser.id
      }
    })

    <span class="cm">// cambiar estado â€” nunca eliminar el registro</span>
    await tx.worker.update({ where: { id }, data: { status: newStatus } })

    <span class="cm">// revocar acceso al sistema si tenÃ­a</span>
    if (worker.userId) {
      await tx.user.update({
        where: { id: worker.userId },
        data:  { role: 'USER' }  <span class="cm">// degradar rol pero no eliminar</span>
      })
    }

    return findWorkerById(id)
  })
}

export async function reentryWorker(id, data, requestUser) {
  const worker = await getWorkerById(id)

  <span class="cm">// regla: solo se puede reingresar a alguien que saliÃ³</span>
  if (!['RESIGNED', 'TERMINATED'].includes(worker.status)) {
    const err = new Error('Solo se puede reingresar a un trabajador que haya salido')
    err.statusCode = 409
    throw err
  }

  return prisma.$transaction(async (tx) => {
    <span class="cm">// registrar reingreso en historial</span>
    await tx.workerMovement.create({
      data: {
        workerId:      id,
        type:          'REENTRY',
        description:   data.description,
        newPosition:   data.position,
        newSalary:     data.salary,
        effectiveDate: data.effectiveDate,
        createdBy:     requestUser.id
      }
    })

    <span class="cm">// reactivar el trabajador con los nuevos datos</span>
    return tx.worker.update({
      where: { id },
      data: {
        status:     'ACTIVE',
        position:   data.position,
        department: data.department,
        salary:     data.salary
      }
    })
  })
}

export async function manageSystemAccess(id, data, requestUser) {
  const worker = await getWorkerById(id)

  return prisma.$transaction(async (tx) => {
    if (data.grantAccess) {
      <span class="cm">// regla: solo a trabajadores activos se les da acceso</span>
      if (worker.status !== 'ACTIVE') {
        const err = new Error('Solo trabajadores activos pueden tener acceso al sistema')
        err.statusCode = 409
        throw err
      }

      if (worker.userId) {
        <span class="cm">// ya tiene acceso â€” solo actualizar rol</span>
        await tx.user.update({
          where: { id: worker.userId },
          data:  { role: data.role ?? 'USER' }
        })
      } else {
        <span class="cm">// crear usuario nuevo con contraseÃ±a temporal</span>
        const tempPassword = await bcrypt.hash('Cambiar123!', 12)
        const user = await tx.user.create({
          data: {
            name:     `${worker.firstName} ${worker.lastName}`,
            email:    worker.email,
            password: tempPassword,
            role:     data.role ?? 'USER'
          }
        })
        await tx.worker.update({ where: { id }, data: { userId: user.id } })
      }
    } else {
      <span class="cm">// revocar acceso â€” desvincular usuario pero no eliminarlo</span>
      if (worker.userId) {
        await tx.worker.update({ where: { id }, data: { userId: null } })
      }
    }

    return findWorkerById(id)
  })
}</pre>
      </div>
    </div>

    <!-- W4: CONTROLLER -->
    <div class="section" id="workers-controller">
      <div class="section-header">
        <div class="step-number">W4</div>
        <div>
          <div class="section-title">MÃ³dulo Trabajadores â€” Controller</div>
          <div class="section-desc">Extrae datos del request, llama al service y responde con el cÃ³digo HTTP correcto.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.controller.js</span><span class="code-lang">js</span></div>
        <pre>import {
  getAllWorkers, getWorkerById, createNewWorker,
  editWorker, changePosition, changeSalary,
  exitWorker, reentryWorker, manageSystemAccess
} from './workers.service.js'
import {
  createWorkerSchema, updateWorkerSchema, positionChangeSchema,
  salaryChangeSchema, exitSchema, reentrySchema,
  systemAccessSchema, getWorkersQuerySchema
} from './workers.schema.js'
import { sanitizeQuery } from '../../shared/utils/sanitize.js'

export async function listWorkersHandler(request, reply) {
  const query = getWorkersQuerySchema.parse(sanitizeQuery(request.query))
  request.log.info({ query }, 'Listando trabajadores')
  const result = await getAllWorkers(query)
  return reply.send(result)
}

export async function getWorkerHandler(request, reply) {
  const worker = await getWorkerById(request.params.id)
  return reply.send(worker)
}

export async function createWorkerHandler(request, reply) {
  const body = createWorkerSchema.parse(request.body)
  request.log.info({ dni: body.dni, createdBy: request.user.id }, 'Creando trabajador')
  const worker = await createNewWorker(body, request.user)
  request.log.info({ workerId: worker.id }, 'Trabajador creado')
  return reply.code(201).send(worker)
}

export async function updateWorkerHandler(request, reply) {
  const body = updateWorkerSchema.parse(request.body)
  request.log.info({ workerId: request.params.id, updatedBy: request.user.id }, 'Editando trabajador')
  const worker = await editWorker(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function positionChangeHandler(request, reply) {
  const body = positionChangeSchema.parse(request.body)
  request.log.info(
    { workerId: request.params.id, newPosition: body.position, by: request.user.id },
    'Cambio de cargo'
  )
  const worker = await changePosition(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function salaryChangeHandler(request, reply) {
  const body = salaryChangeSchema.parse(request.body)
  request.log.info(
    { workerId: request.params.id, newSalary: body.salary, by: request.user.id },
    'Cambio de salario'
  )
  const worker = await changeSalary(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function exitWorkerHandler(request, reply) {
  const body = exitSchema.parse(request.body)
  request.log.warn(
    { workerId: request.params.id, type: body.type, by: request.user.id },
    'Salida de trabajador'
  )
  const worker = await exitWorker(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function reentryWorkerHandler(request, reply) {
  const body = reentrySchema.parse(request.body)
  request.log.info(
    { workerId: request.params.id, by: request.user.id },
    'Reingreso de trabajador'
  )
  const worker = await reentryWorker(request.params.id, body, request.user)
  return reply.send(worker)
}

export async function systemAccessHandler(request, reply) {
  const body = systemAccessSchema.parse(request.body)
  request.log.warn(
    { workerId: request.params.id, grantAccess: body.grantAccess, by: request.user.id },
    'Cambio de acceso al sistema'
  )
  const worker = await manageSystemAccess(request.params.id, body, request.user)
  return reply.send(worker)
}</pre>
      </div>
    </div>

    <!-- W5: ROUTES -->
    <div class="section" id="workers-routes">
      <div class="section-header">
        <div class="step-number">W5</div>
        <div>
          <div class="section-title">MÃ³dulo Trabajadores â€” Routes + Module</div>
          <div class="section-desc">Endpoints protegidos por rol. ADMIN y RRHH gestionan trabajadores.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.routes.js</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { requireRole } from '../../shared/middlewares/roles.middleware.js'
import {
  listWorkersHandler, getWorkerHandler, createWorkerHandler,
  updateWorkerHandler, positionChangeHandler, salaryChangeHandler,
  exitWorkerHandler, reentryWorkerHandler, systemAccessHandler
} from './workers.controller.js'

export async function workersRoutes(fastify) {

  <span class="cm">// GET /api/workers â€” ADMIN y RRHH pueden listar</span>
  fastify.get('/', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Listar trabajadores' }
  }, listWorkersHandler)

  <span class="cm">// GET /api/workers/:id â€” ver detalle con historial</span>
  fastify.get('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Obtener trabajador por ID' }
  }, getWorkerHandler)

  <span class="cm">// POST /api/workers â€” crear nuevo trabajador</span>
  fastify.post('/', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Crear trabajador' }
  }, createWorkerHandler)

  <span class="cm">// PATCH /api/workers/:id â€” editar datos bÃ¡sicos</span>
  <span class="cm">// NO edita cargo, salario ni DNI â€” esos tienen endpoints propios</span>
  fastify.patch('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Editar datos del trabajador' }
  }, updateWorkerHandler)

  <span class="cm">// POST /api/workers/:id/position â€” cambio de cargo formal</span>
  fastify.post('/:id/position', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Cambio de cargo' }
  }, positionChangeHandler)

  <span class="cm">// POST /api/workers/:id/salary â€” cambio de salario</span>
  fastify.post('/:id/salary', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Cambio de salario' }
  }, salaryChangeHandler)

  <span class="cm">// POST /api/workers/:id/exit â€” renuncia o despido</span>
  fastify.post('/:id/exit', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Registrar salida del trabajador' }
  }, exitWorkerHandler)

  <span class="cm">// POST /api/workers/:id/reentry â€” reingreso</span>
  fastify.post('/:id/reentry', {
    preHandler: [requireAuth, requireRole('ADMIN', 'RRHH')],
    schema: { tags: ['Workers'], summary: 'Reingreso de trabajador' }
  }, reentryWorkerHandler)

  <span class="cm">// POST /api/workers/:id/access â€” solo ADMIN gestiona acceso al sistema</span>
  fastify.post('/:id/access', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Workers'], summary: 'Gestionar acceso al sistema' }
  }, systemAccessHandler)
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/workers/workers.module.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import { workersRoutes } from './workers.routes.js'

export const workersModule = fp(async (fastify) => {
  fastify.register(workersRoutes)
})</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js â€” registrar el mÃ³dulo</span><span class="code-lang">js</span></div>
        <pre>import { workersModule } from './modules/workers/workers.module.js'

app.register(workersModule, { prefix: '/api/workers' })</pre>
      </div>

      <h3>// resumen de endpoints</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ endpoints del mÃ³dulo</span><span class="code-lang">bash</span></div>
        <pre>GET    /api/workers              â†’ listar (ADMIN, RRHH)
GET    /api/workers/:id          â†’ detalle + historial (ADMIN, RRHH)
POST   /api/workers              â†’ crear (ADMIN, RRHH)
PATCH  /api/workers/:id          â†’ editar datos bÃ¡sicos (ADMIN, RRHH)
POST   /api/workers/:id/position â†’ cambio de cargo (ADMIN, RRHH)
POST   /api/workers/:id/salary   â†’ cambio de salario (ADMIN, RRHH)
POST   /api/workers/:id/exit     â†’ renuncia o despido (ADMIN, RRHH)
POST   /api/workers/:id/reentry  â†’ reingreso (ADMIN, RRHH)
POST   /api/workers/:id/access   â†’ acceso al sistema (ADMIN solo)</pre>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ”’</span>
        <div>
          <div class="callout-title">DNI y fecha de ingreso son inmutables</div>
          <p>El <code>dni</code> y <code>startDate</code> no estÃ¡n en el <code>updateWorkerSchema</code> â€” es imposible editarlos por la API. Los cambios de cargo y salario tienen sus propios endpoints para que siempre queden registrados en el historial.</p>
        </div>
      </div>
    </div>

  </div><!-- /workers-module -->

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- MÃ“DULO PRODUCTOS                                     -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="content" id="products-module">

    <!-- P1: SCHEMA + ENTIDADES -->
    <div class="section" id="products-schema">
      <div class="section-header">
        <div class="step-number">P1</div>
        <div>
          <div class="section-title">MÃ³dulo Productos â€” Schema + Entidades</div>
          <div class="section-desc">Productos, descuentos, movimientos de stock y sus relaciones.</div>
        </div>
      </div>

      <h3>// 1. entidades del mÃ³dulo</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ prisma/schema.prisma â€” productos</span><span class="code-lang">prisma</span></div>
        <pre><span class="cm">// Entity: Product â€” representa un producto real</span>
model Product {
  id          String          @id @default(uuid())
  name        String
  description String?
  price       Decimal         @db.Decimal(10, 2)
  stock       Int             @default(0)
  imageUrl    String?
  isActive    Boolean         @default(true)    <span class="cm">// desactivar en lugar de eliminar</span>
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  saleItems   SaleItem[]
  discounts   Discount[]                        <span class="cm">// relaciÃ³n con descuentos</span>
  stockMovements StockMovement[]                <span class="cm">// historial de movimientos de stock</span>

  @@index([isActive])
  @@index([name])
  @@map("products")
}

<span class="cm">// Entity: Discount â€” descuentos aplicables a un producto</span>
model Discount {
  id          String       @id @default(uuid())
  productId   String
  product     Product      @relation(fields: [productId], references: [id])
  name        String                            <span class="cm">// ej: "Descuento navideÃ±o"</span>
  percentage  Decimal      @db.Decimal(5, 2)   <span class="cm">// ej: 15.00 = 15%</span>
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean      @default(true)
  createdBy   String                            <span class="cm">// userId de quien lo creÃ³</span>
  createdAt   DateTime     @default(now())

  @@index([productId])
  @@index([isActive])
  @@map("discounts")
}

<span class="cm">// Entity: StockMovement â€” historial inmutable de cada cambio de stock</span>
model StockMovement {
  id          String            @id @default(uuid())
  productId   String
  product     Product           @relation(fields: [productId], references: [id])
  type        StockMovementType
  quantity    Int                               <span class="cm">// positivo = entrada, negativo = salida</span>
  previousStock Int                             <span class="cm">// stock antes del movimiento</span>
  newStock    Int                               <span class="cm">// stock despuÃ©s del movimiento</span>
  description String
  createdBy   String
  createdAt   DateTime          @default(now())

  @@index([productId])
  @@index([type])
  @@map("stock_movements")
}

enum StockMovementType {
  SALE        <span class="cm">// descuento por venta</span>
  RETURN      <span class="cm">// devoluciÃ³n de cliente</span>
  ADJUSTMENT  <span class="cm">// ajuste manual</span>
  PURCHASE    <span class="cm">// entrada por compra</span>
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ’» terminal</span><span class="code-lang">bash</span></div>
        <pre>npx prisma migrate dev --name add-products-module
npx prisma generate</pre>
      </div>

      <h3>// 2. schemas de validaciÃ³n Zod</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.schema.js</span><span class="code-lang">js</span></div>
        <pre>import { z } from 'zod'

<span class="cm">// DTO: crear producto</span>
export const createProductSchema = z.object({
  name:        z.string().min(2).max(200),
  description: z.string().max(1000).optional(),
  price:       z.number().positive('El precio debe ser mayor a 0'),
  stock:       z.number().int().min(0).default(0)
})

<span class="cm">// DTO: editar producto â€” precio se edita aquÃ­ pero stock no</span>
<span class="cm">// el stock solo cambia con movimientos formales</span>
export const updateProductSchema = z.object({
  name:        z.string().min(2).max(200).optional(),
  description: z.string().max(1000).optional(),
  price:       z.number().positive().optional()
  <span class="cm">// stock no estÃ¡ â€” se maneja con stockAdjustmentSchema</span>
})

<span class="cm">// DTO: ajuste manual de stock â€” solo ADMIN</span>
export const stockAdjustmentSchema = z.object({
  quantity:    z.number().int().refine(n => n !== 0, 'La cantidad no puede ser 0'),
  type:        z.enum(['ADJUSTMENT', 'PURCHASE', 'RETURN']),
  description: z.string().min(10, 'Describe el motivo del ajuste')
})

<span class="cm">// DTO: crear descuento</span>
export const createDiscountSchema = z.object({
  name:       z.string().min(2).max(100),
  percentage: z.number().min(0.01).max(100, 'El descuento no puede superar el 100%'),
  startDate:  z.coerce.date(),
  endDate:    z.coerce.date()
}).refine(d => d.endDate > d.startDate, {
  message: 'La fecha de fin debe ser posterior a la de inicio',
  path: ['endDate']
})

<span class="cm">// DTO: query params</span>
export const getProductsQuerySchema = z.object({
  page:     z.coerce.number().int().positive().default(1),
  limit:    z.coerce.number().int().positive().max(100).default(10),
  isActive: z.coerce.boolean().optional(),
  search:   z.string().optional()
})</pre>
      </div>
    </div>

    <!-- P2: REPOSITORY -->
    <div class="section" id="products-repository">
      <div class="section-header">
        <div class="step-number">P2</div>
        <div>
          <div class="section-title">MÃ³dulo Productos â€” Repository</div>
          <div class="section-desc">Consultas a la base de datos para productos, stock y descuentos.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.repository.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'

export async function findAllProducts({ page = 1, limit = 10, isActive, search } = {}) {
  const skip = (page - 1) * limit
  const where = {}

  if (isActive !== undefined) where.isActive = isActive
  if (search) {
    where.OR = [
      { name:        { contains: search, mode: 'insensitive' } },
      { description: { contains: search, mode: 'insensitive' } }
    ]
  }

  const [data, total] = await Promise.all([
    prisma.product.findMany({
      where,
      skip,
      take: limit,
      select: {
        id: true, name: true, description: true,
        price: true, stock: true, isActive: true,
        imageUrl: true, createdAt: true,
        <span class="cm">// incluir descuentos activos junto con el producto</span>
        discounts: {
          where: {
            isActive:  true,
            startDate: { lte: new Date() },
            endDate:   { gte: new Date() }
          },
          select: { id: true, name: true, percentage: true, endDate: true }
        }
      },
      orderBy: { name: 'asc' }
    }),
    prisma.product.count({ where })
  ])

  return { data, total }
}

export async function findProductById(id) {
  return prisma.product.findUnique({
    where: { id },
    include: {
      discounts:      { orderBy: { createdAt: 'desc' } },
      stockMovements: { orderBy: { createdAt: 'desc' }, take: 20 }
    }
  })
}

export async function createProduct(data) {
  return prisma.product.create({ data })
}

export async function updateProduct(id, data) {
  return prisma.product.update({ where: { id }, data })
}

export async function createStockMovement(data) {
  return prisma.stockMovement.create({ data })
}

export async function createDiscount(data) {
  return prisma.discount.create({ data })
}

export async function updateDiscount(id, data) {
  return prisma.discount.update({ where: { id }, data })
}</pre>
      </div>
    </div>

    <!-- P3: SERVICE -->
    <div class="section" id="products-service">
      <div class="section-header">
        <div class="step-number">P3</div>
        <div>
          <div class="section-title">MÃ³dulo Productos â€” Service</div>
          <div class="section-desc">Reglas de negocio para productos, stock y descuentos.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.service.js</span><span class="code-lang">js</span></div>
        <pre>import { prisma } from '../../shared/plugins/prisma.plugin.js'
import {
  findAllProducts, findProductById, createProduct,
  updateProduct, createStockMovement, createDiscount, updateDiscount
} from './products.repository.js'
import { buildPagination } from '../../shared/utils/pagination.js'

export async function getAllProducts(query) {
  const { data, total } = await findAllProducts(query)
  return buildPagination(data, total, query.page, query.limit)
}

export async function getProductById(id) {
  const product = await findProductById(id)
  if (!product) {
    const err = new Error('Producto no encontrado')
    err.statusCode = 404
    throw err
  }
  return product
}

export async function createNewProduct(data, requestUser) {
  const product = await createProduct(data)

  <span class="cm">// registrar el ingreso inicial de stock si es mayor a 0</span>
  if (data.stock > 0) {
    await createStockMovement({
      productId:     product.id,
      type:          'PURCHASE',
      quantity:      data.stock,
      previousStock: 0,
      newStock:      data.stock,
      description:   'Stock inicial al crear el producto',
      createdBy:     requestUser.id
    })
  }

  return product
}

export async function editProduct(id, data, requestUser) {
  const product = await getProductById(id)

  <span class="cm">// regla: solo productos activos se pueden editar</span>
  if (!product.isActive) {
    const err = new Error('No se puede editar un producto desactivado')
    err.statusCode = 409
    throw err
  }

  return updateProduct(id, data)
}

export async function adjustStock(id, data, requestUser) {
  const product = await getProductById(id)

  if (!product.isActive) {
    const err = new Error('No se puede ajustar el stock de un producto desactivado')
    err.statusCode = 409
    throw err
  }

  const newStock = product.stock + data.quantity

  <span class="cm">// regla: el stock no puede quedar negativo</span>
  if (newStock < 0) {
    const err = new Error(`Stock insuficiente. Stock actual: ${product.stock}, ajuste solicitado: ${data.quantity}`)
    err.statusCode = 409
    throw err
  }

  return prisma.$transaction(async (tx) => {
    <span class="cm">// registrar el movimiento antes de actualizar</span>
    await tx.stockMovement.create({
      data: {
        productId:     id,
        type:          data.type,
        quantity:      data.quantity,
        previousStock: product.stock,
        newStock,
        description:   data.description,
        createdBy:     requestUser.id
      }
    })

    <span class="cm">// actualizar el stock del producto</span>
    return tx.product.update({
      where: { id },
      data:  { stock: newStock }
    })
  })
}

export async function deactivateProduct(id, requestUser) {
  const product = await getProductById(id)

  if (!product.isActive) {
    const err = new Error('El producto ya estÃ¡ desactivado')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// desactivar â€” nunca eliminar para mantener historial</span>
  return updateProduct(id, { isActive: false })
}

export async function reactivateProduct(id, requestUser) {
  const product = await getProductById(id)

  if (product.isActive) {
    const err = new Error('El producto ya estÃ¡ activo')
    err.statusCode = 409
    throw err
  }

  return updateProduct(id, { isActive: true })
}

export async function addDiscount(productId, data, requestUser) {
  const product = await getProductById(productId)

  if (!product.isActive) {
    const err = new Error('No se pueden agregar descuentos a un producto desactivado')
    err.statusCode = 409
    throw err
  }

  <span class="cm">// regla: no puede haber dos descuentos activos que se solapen en fechas</span>
  const overlapping = await prisma.discount.findFirst({
    where: {
      productId,
      isActive: true,
      AND: [
        { startDate: { lte: data.endDate } },
        { endDate:   { gte: data.startDate } }
      ]
    }
  })

  if (overlapping) {
    const err = new Error(`Ya existe un descuento activo en ese perÃ­odo: "${overlapping.name}"`)
    err.statusCode = 409
    throw err
  }

  return createDiscount({ ...data, productId, createdBy: requestUser.id })
}

export async function deactivateDiscount(discountId, requestUser) {
  const discount = await prisma.discount.findUnique({ where: { id: discountId } })

  if (!discount) {
    const err = new Error('Descuento no encontrado')
    err.statusCode = 404
    throw err
  }

  if (!discount.isActive) {
    const err = new Error('El descuento ya estÃ¡ desactivado')
    err.statusCode = 409
    throw err
  }

  return updateDiscount(discountId, { isActive: false })
}</pre>
      </div>
    </div>

    <!-- P4: CONTROLLER -->
    <div class="section" id="products-controller">
      <div class="section-header">
        <div class="step-number">P4</div>
        <div>
          <div class="section-title">MÃ³dulo Productos â€” Controller</div>
          <div class="section-desc">Handlers HTTP para productos, stock y descuentos.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.controller.js</span><span class="code-lang">js</span></div>
        <pre>import {
  getAllProducts, getProductById, createNewProduct,
  editProduct, adjustStock, deactivateProduct,
  reactivateProduct, addDiscount, deactivateDiscount
} from './products.service.js'
import {
  createProductSchema, updateProductSchema, stockAdjustmentSchema,
  createDiscountSchema, getProductsQuerySchema
} from './products.schema.js'
import { sanitizeQuery } from '../../shared/utils/sanitize.js'

export async function listProductsHandler(request, reply) {
  const query = getProductsQuerySchema.parse(sanitizeQuery(request.query))
  const result = await getAllProducts(query)
  return reply.send(result)
}

export async function getProductHandler(request, reply) {
  const product = await getProductById(request.params.id)
  return reply.send(product)
}

export async function createProductHandler(request, reply) {
  const body = createProductSchema.parse(request.body)
  request.log.info({ name: body.name, createdBy: request.user.id }, 'Creando producto')
  const product = await createNewProduct(body, request.user)
  request.log.info({ productId: product.id }, 'Producto creado')
  return reply.code(201).send(product)
}

export async function updateProductHandler(request, reply) {
  const body = updateProductSchema.parse(request.body)
  request.log.info({ productId: request.params.id, updatedBy: request.user.id }, 'Editando producto')
  const product = await editProduct(request.params.id, body, request.user)
  return reply.send(product)
}

export async function stockAdjustmentHandler(request, reply) {
  const body = stockAdjustmentSchema.parse(request.body)
  request.log.warn(
    { productId: request.params.id, quantity: body.quantity, type: body.type, by: request.user.id },
    'Ajuste de stock'
  )
  const product = await adjustStock(request.params.id, body, request.user)
  return reply.send(product)
}

export async function deactivateProductHandler(request, reply) {
  request.log.warn({ productId: request.params.id, by: request.user.id }, 'Desactivando producto')
  const product = await deactivateProduct(request.params.id, request.user)
  return reply.send(product)
}

export async function reactivateProductHandler(request, reply) {
  request.log.info({ productId: request.params.id, by: request.user.id }, 'Reactivando producto')
  const product = await reactivateProduct(request.params.id, request.user)
  return reply.send(product)
}

export async function addDiscountHandler(request, reply) {
  const body = createDiscountSchema.parse(request.body)
  request.log.info(
    { productId: request.params.id, discount: body.name, by: request.user.id },
    'Agregando descuento'
  )
  const discount = await addDiscount(request.params.id, body, request.user)
  return reply.code(201).send(discount)
}

export async function deactivateDiscountHandler(request, reply) {
  request.log.warn(
    { discountId: request.params.discountId, by: request.user.id },
    'Desactivando descuento'
  )
  const discount = await deactivateDiscount(request.params.discountId, request.user)
  return reply.send(discount)
}</pre>
      </div>
    </div>

    <!-- P5: ROUTES -->
    <div class="section" id="products-routes">
      <div class="section-header">
        <div class="step-number">P5</div>
        <div>
          <div class="section-title">MÃ³dulo Productos â€” Routes + Module</div>
          <div class="section-desc">Endpoints pÃºblicos para consulta y protegidos por rol para gestiÃ³n.</div>
        </div>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.routes.js</span><span class="code-lang">js</span></div>
        <pre>import { requireAuth } from '../../shared/middlewares/auth.middleware.js'
import { requireRole } from '../../shared/middlewares/roles.middleware.js'
import {
  listProductsHandler, getProductHandler, createProductHandler,
  updateProductHandler, stockAdjustmentHandler, deactivateProductHandler,
  reactivateProductHandler, addDiscountHandler, deactivateDiscountHandler
} from './products.controller.js'

export async function productsRoutes(fastify) {

  <span class="cm">// GET /api/products â€” pÃºblico, cualquiera puede ver productos activos</span>
  fastify.get('/', {
    schema: { tags: ['Products'], summary: 'Listar productos' }
  }, listProductsHandler)

  <span class="cm">// GET /api/products/:id â€” pÃºblico</span>
  fastify.get('/:id', {
    schema: { tags: ['Products'], summary: 'Obtener producto por ID' }
  }, getProductHandler)

  <span class="cm">// POST /api/products â€” solo ADMIN crea productos</span>
  fastify.post('/', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Crear producto' }
  }, createProductHandler)

  <span class="cm">// PATCH /api/products/:id â€” ADMIN edita nombre, descripciÃ³n y precio</span>
  <span class="cm">// el stock NO se edita aquÃ­ â€” tiene endpoint propio</span>
  fastify.patch('/:id', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Editar producto' }
  }, updateProductHandler)

  <span class="cm">// POST /api/products/:id/stock â€” ajuste manual de stock</span>
  <span class="cm">// ADJUSTMENT, PURCHASE y RETURN van aquÃ­ â€” SALE lo hace el mÃ³dulo ventas</span>
  fastify.post('/:id/stock', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Ajuste de stock' }
  }, stockAdjustmentHandler)

  <span class="cm">// PATCH /api/products/:id/deactivate â€” desactivar producto</span>
  fastify.patch('/:id/deactivate', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Desactivar producto' }
  }, deactivateProductHandler)

  <span class="cm">// PATCH /api/products/:id/reactivate â€” reactivar producto</span>
  fastify.patch('/:id/reactivate', {
    preHandler: [requireAuth, requireRole('ADMIN')],
    schema: { tags: ['Products'], summary: 'Reactivar producto' }
  }, reactivateProductHandler)

  <span class="cm">// POST /api/products/:id/discounts â€” agregar descuento (ADMIN, PRICING)</span>
  fastify.post('/:id/discounts', {
    preHandler: [requireAuth, requireRole('ADMIN', 'PRICING')],
    schema: { tags: ['Products'], summary: 'Agregar descuento' }
  }, addDiscountHandler)

  <span class="cm">// PATCH /api/products/:id/discounts/:discountId/deactivate</span>
  fastify.patch('/:id/discounts/:discountId/deactivate', {
    preHandler: [requireAuth, requireRole('ADMIN', 'PRICING')],
    schema: { tags: ['Products'], summary: 'Desactivar descuento' }
  }, deactivateDiscountHandler)
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/modules/products/products.module.js</span><span class="code-lang">js</span></div>
        <pre>import fp from 'fastify-plugin'
import { productsRoutes } from './products.routes.js'

export const productsModule = fp(async (fastify) => {
  fastify.register(productsRoutes)
})</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ src/app.js â€” registrar el mÃ³dulo</span><span class="code-lang">js</span></div>
        <pre>import { productsModule } from './modules/products/products.module.js'

app.register(productsModule, { prefix: '/api/products' })</pre>
      </div>

      <h3>// resumen de endpoints</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-filename">ğŸ“„ endpoints del mÃ³dulo</span><span class="code-lang">bash</span></div>
        <pre>GET    /api/products                               â†’ listar (pÃºblico)
GET    /api/products/:id                           â†’ detalle (pÃºblico)
POST   /api/products                               â†’ crear (ADMIN)
PATCH  /api/products/:id                           â†’ editar (ADMIN)
POST   /api/products/:id/stock                     â†’ ajuste stock (ADMIN)
PATCH  /api/products/:id/deactivate                â†’ desactivar (ADMIN)
PATCH  /api/products/:id/reactivate                â†’ reactivar (ADMIN)
POST   /api/products/:id/discounts                 â†’ crear descuento (ADMIN, PRICING)
PATCH  /api/products/:id/discounts/:id/deactivate  â†’ desactivar descuento (ADMIN, PRICING)</pre>
      </div>

      <div class="callout info">
        <span class="callout-icon">ğŸ’¡</span>
        <div>
          <div class="callout-title">El stock de ventas lo maneja el mÃ³dulo ventas</div>
          <p>Cuando se crea una venta, el mÃ³dulo de ventas descuenta el stock directamente en su transacciÃ³n usando <code>tx.product.update</code>. El mÃ³dulo de productos solo maneja ajustes manuales (compras, devoluciones, correcciones). AsÃ­ cada mÃ³dulo mantiene su responsabilidad clara.</p>
        </div>
      </div>

    </div>

  </div><!-- /products-module -->

</main>

<script>
  window.addEventListener('scroll', () => {
    const el = document.getElementById('progress')
    const total = document.body.scrollHeight - window.innerHeight
    el.style.width = (window.scrollY / total * 100) + '%'
  })

  function setActive(el) {
    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'))
    el.classList.add('active')
  }

  const sections = document.querySelectorAll('[id]')
  const navItems = document.querySelectorAll('.nav-item[href]')
  window.addEventListener('scroll', () => {
    let current = ''
    sections.forEach(s => { if (window.scrollY >= s.offsetTop - 120) current = s.id })
    navItems.forEach(n => n.classList.toggle('active', n.getAttribute('href') === '#' + current))
  })
</script>
</body>
</html>
